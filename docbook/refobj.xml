<!--

Copyright 2012-2014 Double Precision, Inc.
See COPYING for distribution information.

-->

<chapter id="refobj">
  <title>Reference-counted objects</title>

  <para>
    Nearly all objects in &app; are reference-counted objects, which
    are similar to what <classname>std::shared_ptr</classname>
    implements, but with notable differences, as described here.
    In this context, this is not the same kind of a <quote>reference</quote>
    that's defined in the C++ language.
    For clarity, <quote>native references</quote> will refer to traditional
    C++ references, while the general usage of the term <quote>reference
      pointer</quote>, or a
    <quote>reference</quote>, refers to the construct described here.
  </para>

  <para>
    Reference-counted objects do not get
    accessed with an ordinary pointer, but by using a <emphasis>reference
      pointer</emphasis>, an &reforptr;.
    A reference-counted object gets instantiated on the heap, using
    a variadic <methodname>create</methodname>() function that forwards its
    arguments to the object's constructor;
    <methodname>create</methodname>()
    instantiates the object on the heap and
    constructs the first, initial reference pointer to the
    newly-instantiated object.
  </para>

  <para>
    Reference pointers look like ordinary pointers. They have
    <literal>*</literal> and <literal>-&gt;</literal> operators that
    have the expected behavior. Reference pointers may be freely copied and
    passed around.
  </para>

  <para>
    <function>new</function> does not get used, explicitly, to instantiate
    objects on the heap, this is taken care of by <methodname>create</methodname>().
    Similarly, <function>delete</function> does not get used, explicitly, with
    reference-counted objects.
    When the last reference to an object goes out of scope and longer exists,
    the last reference pointer takes care of destroying the object
    with a <literal>delete</literal>, and invoking any
    <link linkend="ondestroy">destructor callbacks</link>.
  </para>

  &nopthreadcancel;

  <section id="refcmp">
    <title>Comparison with other implementations of reference-counted objects</title>

    <para>
      This implementation of reference-counted objects is
      similar to other similar implementations, notably
      <classname>shared_ptr</classname> in the C++ library, however there are
      fundamental differences. The key differences are:
    </para>

    <itemizedlist>
      <listitem>
	<para>
	  gcc's implementation of <classname>shared_ptr</classname>
	  is derived from an implementation in the Boost library, which
	  appears to be not
	  <ulink url="http://gcc.gnu.org/ml/libstdc++/2013-08/msg00161.html">thread-safe</ulink>.
	  This implementation of reference-counted objects is thread safe.
	</para>
      </listitem>

      <listitem>
	<para>
	  A <classname>shared_ptr</classname>
	  contains a pointer to a small heap-allocated object
	  that stores the reference count, and a second pointer to the
	  actual object:
	</para>

	<mediaobject>
	  <imageobject>
	    <imagedata fileref="sharedptr.png" />
	  </imageobject>
	</mediaobject>
      </listitem>

      <listitem>
	<para>
	  &app;'s reference-counted objects use a different approach
	  that's similar to Java's implementation of managed objects.
	  &app;'s reference-counted objects are derived from an
	  <classname>&ns;::obj</classname> superclass, which stores
	  the reference
	  count.
	  There are two main reference pointer classes,
	  &ref; and &ptr;, holding a single pointer
	  to the object:
	</para>

	<mediaobject>
	  <imageobject>
	    <imagedata fileref="ref.png" />
	  </imageobject>
	</mediaobject>
      </listitem>

      <listitem>
	<para>
	  <classname>shared_ptr</classname>'s
	  <methodname>*</methodname> and
	  <methodname>-&gt;</methodname> operators
	  dereference a mutable object,
	  and dereferencing a <literal>nullptr</literal> is
	  ill-formed.
	  &ptr; can also be a <literal>nullptr</literal>, but dereferencing a
	  <literal>nullptr</literal> is not ill-formed:
	  an exception gets thrown, with defined semantics.
	  &ref;'s <methodname>*</methodname> and <methodname>-&gt;</methodname>
	  operators do not check for a <literal>nullptr</literal>
	  because &ref; cannot be a <literal>nullptr</literal>, it must always
	  refer to an object. This is enforced by contract.
	  The <literal>nullptr</literal>
	  gets checked when an &ref; gets assigned to.
	  &ref; is proven, by contract, never to contain a
	  <literal>nullptr</literal>; hence its
	  <methodname>*</methodname> and <methodname>-&gt;</methodname> directly
	  dereferences the internal pointer to the underlying object.
	</para>

	<para>
	  An &ref; lvalue is convertible to an &ptr; lvalue without a temporary.
	  Converting an &ptr; to an &ref; checks for a
	  <literal>nullptr</literal>
	  at the time the conversion takes place, where an exception gets
	  thrown. An &ptr; may be passed to a function that takes an &ref;
	  argument. If the caller supplies a <literal>nullptr</literal>,
	  the exception gets thrown in the caller's context, for violating
	  the contract. The backtrace accurately points to the guilty party,
	  not the function, but its caller.
	</para>
      </listitem>

      <listitem>
	<para>
	  &ptr; and &ref; are analogous to natural C++ pointers and
	  references. Similarly, &app; defines an &const_ptr; and an
	  &const_ref;, that dereference to constant objects. This is
	  directly analogous to a <classname>std::iterator</classname> and a
	  <classname>std::const_iterator</classname>. Nothing similar is
	  available with a <classname>shared_ptr</classname>.
	  A <classname>shared_ptr&lt;T&gt;</classname> is convertible to a
	  <classname>shared_ptr&lt;const T&gt;</classname>, but doing that
	  for a function call requires the construction of a temporary.
	  An &ptr; lvalue converts to an &const_ptr;
	  lvalue without a temporary,
	  ditto for &ref; and an &const_ref;.
	</para>
      </listitem>
    </itemizedlist>

    <para>
      The primary benefit of using <classname>shared_ptr</classname>
      is that it allows any class to acquire reference-counting
      semantics without modification. Standard C++ library classes, such as
      various stream objects, can be easily wrapped into a
      reference-counted framework.
    </para>

    <para>
      However, there are several disadvantages to
      <classname>shared_ptr</classname> that &ref; and &ptr; seek to address.
    </para>

    <itemizedlist>
      <listitem>
	<para>
	  Each reference-counted object requires allocating another small
	  object, the reference counter, from the heap. Over the long term,
	  this is more likely to increase
	  heap fragmentation, and heap usage, especially
	  in long running applications, as reference-counted objects get
	  created and destroyed.
	</para>
      </listitem>

      <listitem>
	<para>
	  There is no straightforward way to prove, by contract, that a
	  <classname>shared_ptr</classname> instance is not a
	  <literal>nullptr</literal>.
	</para>
      </listitem>

      <listitem>
	<para>
	  It's not possible to construct a <classname>shared_ptr</classname>
	  from <literal>this</literal>, unless the class explicitly
	  inherits from an <classname>enable_shared_from_this</classname>
	  superclass. But this cancels out
	  <classname>shared_ptr</classname> primary benefit of wrapping any
	  arbitrary class. Furthermore, this approach becomes somewhat
	  difficult when multiple inheritance gets involved.
	</para>
      </listitem>
    </itemizedlist>

    <para>
      &app; stores the reference count in each object's superclass,
      <classname>&ns;::obj</classname> which is
      directly accessible by any subclass. A new &reforptr;
      gets constructed directly from <varname>this</varname>,
      without much fanfare.
      This creates a new reference, and increments
      the object's reference count.
    </para>

    <para>
      Furthermore, since the counter is a part of the object, it does not
      need to be allocated separately, on the heap. The only drawback is that,
      unlike with <classname>shared_ptr</classname>, it's not possible to
      implement reference-counted semantics for an arbitrary class. It is
      necessary to declare a subclass that multiply
      inherits from that class, and
      from <classname>&ns;::obj</classname>.
    </para>

    <para>
      &ref;s and &ptr;s work with multiple inheritance without any special
      effort. Each reference-counted class
      virtually inherits from <classname>&ns;::obj</classname>, which
      automatically does the right thing when multiple reference-counted
      classes get inherited from.
    </para>
  </section>

  <section id="obj">
    <title>Objects</title>

    <para>
      In this library, all reference-counted
      objects are virtually derived from the
      <ulink url="&link-x--obj;"><classname>&ns;::obj</classname></ulink>
    class:</para>

    <blockquote>
      <informalexample>
	<programlisting>
#include &lt;&ns;/obj.H&gt;

class buttonObj: virtual public &ns;::obj {

// ...

public:

    buttonObj(int width, int height);
    ~buttonObj();
};

//

#include &lt;&ns;/ref.H&gt;
#include &lt;&ns;/ptr.H&gt;

typedef &ns;::ref&lt;buttonObj&gt; button;

typedef &ns;::ptr&lt;buttonObj&gt; buttonptr;

typedef &ns;::const_ref&lt;buttonObj&gt; const_button;

typedef &ns;::const_ptr&lt;buttonObj&gt; const_buttonptr;

button okButton=button::create(100, 100);</programlisting>
</informalexample>
    </blockquote>

    <para>
      <classname>&ns;::obj</classname> is the virtual superclass of all
      reference-counted objects. Objects derived from
      <classname>&ns;::obj</classname> must always be allocated from the
      heap using <methodname>create</methodname>() (described later).
    </para>

    <para>
      <methodname>create</methodname>() returns a
      <link linkend="ref">reference pointer</link> to the newly-constructed
      class instance, either &ref;, or an &ptr;, as described later.
    </para>

    <para>
      Once allocated on the heap, reference-counted objects do not get copied.
      <classname>&ns;::obj</classname> does not implement a copy constructor
      or the assignment operator.
      Subclasses of <classname>&ns;::obj</classname> may define their own
      copy constructors and assignment operators, whose scope is limited to
      the subclass.
    </para>

    <para>
      By convention, names of classes derived from
      <classname>&ns;::obj</classname> end with <quote>Obj</quote>.
      <classname>&ns;::obj</classname> maintains an internal counter tracking
      all outstanding references to the object.
      All classes derived from
      <classname>&ns;::obj</classname>
      must be derived virtually.
      This is required to correctly implement multiple inheritance.
      Inheriting from multiple
      <classname>&ns;::obj</classname>-derived classes ends up with a single
      instance of the virtual <classname>&ns;::obj</classname> superclass of
      the derived class, and a single counter, that properly tracks all
      references to the derived object.
    </para>

    <note>
      <para>
	Destructors of reference-counted objects cannot throw exceptions.
	All classes derived from <classname>&ns;::obj</classname> should
	not use the <literal>noexcept(false)</literal> override.
      </para>
    </note>
  </section>

  <section id="ref">
    <title>Pointers and references</title>
    <para>
      Two templates,
      <ulink url="&link-x--ptr;">&ptr;</ulink>
      and
	<ulink url="&link-x--ref;">&ref;</ulink>
	keep track of reference-counted objects:
    </para>

    <blockquote>
      <informalexample>
	<programlisting>
#include &lt;&ns;/ptr.H&gt;

typedef &ns;::ptr&lt;buttonObj&gt; button;

button b(button::create(200, 300));

// ...

b-&gt;click();


// Alternatively:

#include &lt;&ns;/ref.H&gt;

typedef &ns;::ref&lt;buttonObj&gt; button;

button b(button::create(200, 300));</programlisting>
      </informalexample>
    </blockquote>

    <para>
      As previously mentioned, reference-counted objects get allocated on the
      heap, but not by using <literal>new</literal>.
      This is done by the overloaded <function>create</function>()
      function.
      The <link linkend="create">description of this variadic method</link>,
      a member of both
      <classname>&ns;::ref</classname> and <classname>&ns;::ptr</classname>,
      follows later.
      The variadic <methodname>create</methodname>() forwards its parameters
      to the constructor for the
      reference-counted class, that gets instantiated on the heap.
      In this example,
      when <varname>b</varname>, and all other references go out of scope, the
      underlying object gets destroyed. An explicit
      <literal>delete</literal> never gets used after constructing
      a reference-counted object. It gets invoked automatically, by the last
      &reforptr; when it goes out of scope.
    </para>

    <para>
      The only difference between an &ptr; and an
      &ref; is that an &ref; always
      refers to an object (and therefore does not have a default constructor,
      since it must be constructed with some object, usually a
      <methodname>create</methodname>() one, at hand.
      &ptr;, however, does not have to refer to an instance of a
      reference-counted class, and may be undefined, this is
      analogous to a <literal>nullptr</literal>:
    </para>

    <blockquote>
      <informalexample>
	<programlisting>
typedef &ns;::ptr&lt;buttonObj&gt; buttonptr;

buttonptr b;

// ...

if (!b.null())
   b->method();</programlisting>
      </informalexample>
    </blockquote>

    <para>
      An &ref; does not have a
      <methodname>null</methodname>(), because it always refers to some object.
      An &ref; can always be converted to an
      &ptr; to the same class.
      An &ptr; can also be converted to an
      &ref;, but if its unbound, an
      <link linkend="exceptions">exception</link> gets thrown at the point the
      conversion is attempted.
    </para>

    <para>
      It follows that an &ref; does not have
      a default constructor. All &ref;s
      must be constructed to refer to some existing instance of the
      referenced class.
    </para>

    <blockquote>
      <informalexample>
	<programlisting>
class buttonObj {

public:
    buttonObj(int width, int height);

// ...

    void click();

};

typedef &ns;::ref&lt;buttonObj&gt; button;

button b(button::create(400, 200));

// ...

b-&gt;click();</programlisting>
      </informalexample>
    </blockquote>

    <para>
      Calling <methodname>create</methodname>() is just like calling
      <literal>new <replaceable>classname</replaceable></literal>,
      where <replaceable>classname</replaceable> is the referenced object.
      This creates a new object using the arguments passed to
      <methodname>create</methodname>().
      With no arguments, the default constructor gets used. Passing
      additional arguments to <methodname>create</methodname>() invokes
      the appropriate constructor for the new object.
    </para>

    <para id="thrsafenote">
      Each individual &reforptr; can only be accessed by one thread, at a time,
      but different threads may have separate &ref;s and &ptr;s referencing
      the same object, and use their own &ref;s and &ptr;s, without
      coordinating with other threads. Reference counting by different
      &ref;s and &ptr;s is thread-safe.
      The object gets destroyed
      when all &ref;s and &ptr;s to the object, in all threads, go out of
      scope.
      The object's destructor gets invoked by the thread that held the
      last &reforptr; to the object, which may not necessarily be the same
      thread that constructed the object.
      Whichever lucky winner let the last &reforptr; go out of scope gets
      to destroy the object, and invoke its
      <link linkend="ondestroy">destructor callbacks</link>.
    </para>

    <note>
      <para>
	In this context, thread safety also
	does not mean that all classes derived from
	<classname>&ns;::obj</classname>
	are automatically thread safe, just that their reference-counting
	is thread safe.
	Classes used by multiple threads are responsible for
	providing thread-safe class method implementations.
      </para>
    </note>

    <para>
      As mentioned previously,
      unlike an &ref;, a &ptr; may not be bound to any actual
      object:
    </para>

    <blockquote>
      <informalexample>
	<programlisting>
typedef &ns;::ptr&lt;buttonObj&gt; button;

button b;

// ...

if (b.null())
{

    // ...
}</programlisting>
      </informalexample>
    </blockquote>

    <para>
	Here, <varname>b</varname> gets instantiated without referring to any
	object. Using <literal>*</literal> and <literal>-&gt;</literal> on an
	unbound &ptr; throws an exception, until the &ptr; is assigned
	to an actual object.
	<methodname>null</methodname>() returns true when the &ptr; is
	not bound to any object.
      </para>
  </section>

  <section id="constrefobj">
    <title><classname>&ns;::const_ref</classname> and <classname>&ns;::const_ptr</classname></title>

    <para>
      <ulink url="&link-x--const-ref;"><classname>&ns;::const_ref</classname></ulink>
      and
      <ulink url="&link-x--const-ptr;"><classname>&ns;::const_ptr</classname></ulink>
      are versions of
      &ref; and &ptr;
      whose <literal>*</literal> and <literal>-&gt;</literal> operators
      resolve to a constant object,
      similar to the relation between <classname>std::iterator</classname>
      and <classname>std::const_iterator</classname> in the C++ library.
      They are subclasses of <classname>&ns;::ref</classname> and
      <classname>&ns;::ptr</classname> (actually they're superclasses, but
      it's easier to think of them as subclasses).
      Passing an &reforptr; to a function that takes an equivalent const
      argument does not require the creation of a temporary object:
    </para>

    <blockquote>
      <informalexample>
	<programlisting>
class buttonObj : virtual public &ns;::obj {

// ...

};

typedef &ns;::ref&lt;buttonObj&gt; button;

typedef &ns;::ptr&lt;buttonObj&gt; buttonptr;


typedef &ns;::const_ref&lt;buttonObj&gt; const_button;

typedef &ns;::const_ptr&lt;buttonObj&gt; const_buttonptr;

// ...

void draw(const const_button &amp;b);

// ...

button buttonref=button::create();

// ...

draw(buttonref);</programlisting>
       </informalexample>
    </blockquote>

    <para>
      In this example, <quote>draw()</quote> does not create a temporary.
      It just passes a reference to the <classname>&ns;::const_ref</classname>
      superclass of the <classname>&ns;::ref</classname>, with the contract
      that the <classname>&ns;::const_ref</classname> gives access only to
      <literal>const</literal> class methods and members.
    </para>

    <para>
      The above example shows &app;'s naming convention for
      reference-counted objects and reference types:
    </para>

    <informaltable>
      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>
	      Name
	    </entry>
	    <entry>
	      What it is
	    </entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry>class&nbsp;<classname><replaceable>something</replaceable>Obj</classname></entry>

	    <entry>
	      Virtually derived from <classname>&ns;::obj</classname>, a
	      reference-counted class.
	    </entry>
	  </row>
	  <row>
	    <entry>typedef&nbsp;&ns;::ref&lt;<classname><replaceable>something</replaceable>Obj</classname>&gt;&nbsp;<classname><replaceable>something</replaceable></classname></entry>
	    <entry>
	      A non-<literal>nullptr</literal> reference to a reference-counted
	      object.
	      <methodname><replaceable>something</replaceable>::create</methodname>(<replaceable>args</replaceable>)
	      calls <literal>new <classname><replaceable>something</replaceable>Obj</classname>(<replaceable>args</replaceable>)</literal>,
	      and returns a reference to the newly-constructed object.
	    </entry>
	  </row>
	  <row>
	    <entry>typedef&nbsp;&ns;::const_ref&lt;<classname><replaceable>something</replaceable>Obj</classname>&gt;&nbsp;<classname>const_<replaceable>something</replaceable></classname></entry>
	    <entry>
	      A non-<literal>nullptr</literal> reference to a
	      constant reference-counted object.
	      <literal>*</literal> and <literal>-&gt;</literal> operators
	      resolve to a constant object.
	    </entry>
	  </row>
	  <row>
	    <entry>typedef&nbsp;&ns;::ptr&lt;<classname><replaceable>something</replaceable>Obj</classname>&gt;&nbsp;<classname><replaceable>something</replaceable>ptr</classname></entry>
	    <entry>
	      A reference-counted pointer, which may be a
	      <literal>nullptr</literal>.
	      <methodname><replaceable>something</replaceable>ptr::create</methodname>(<replaceable>args</replaceable>)
	      calls <literal>new <classname><replaceable>something</replaceable>Obj</classname>(<replaceable>args</replaceable>)</literal>,
	      and returns a pointer reference to the newly-constructed object.
	      Dereferencing a <literal>nullptr</literal>
	      <classname><replaceable>something</replaceable>ptr</classname>
	      throws an exception.
	    </entry>
	  </row>
	  <row>
	    <entry>typedef&nbsp;&ns;::const_ptr&lt;<classname>const_<replaceable>something</replaceable>Obj</classname>&gt;&nbsp;<classname>const_<replaceable>something</replaceable>ptr</classname></entry>
	    <entry>
	      A reference-counted pointer to a constant object, which may be a
	      <literal>nullptr</literal>.
	      <literal>*</literal> and <literal>-&gt;</literal> operators
	      resolve to a constant object.
	      Dereferencing a <literal>nullptr</literal>
	      <classname>const_<replaceable>something</replaceable>ptr</classname>
	      throws an exception.
	    </entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>
  </section>

  <section id="create">
    <title><methodname>create</methodname>() - create reference-counted objects</title>

    <blockquote>
      <informalexample>
	<programlisting>
#include &lt;&ns;/ref.H&gt;
#include &lt;&ns;/ptr.H&gt;

class buttonObj : virtual public &ns;::obj {

public:
    buttonObj(int width, int height);
    ~buttonObj();

// ...

};

typedef &ns;::ref&lt;buttonObj&gt; button;
typedef &ns;::ptr&lt;buttonObj&gt; buttonptr;

button quit(button::create(100, 100));</programlisting>
      </informalexample>
    </blockquote>

    <para>
      An &ref; and an
      &ptr; defines a member
      <literal>typedef</literal> named <classname>base</classname>. This is a
      <literal>typedef</literal> to a class with static methods, or other
      members that are provided by the &ref; or the
      &ptr;, to supplement the class
      <literal>*</literal> and <literal>-&gt;</literal> method operators.
      An &ref;'s and &ptr;'s <methodname>create</methodname>() is actually
      a call to <methodname>base::objfactory&lt;<replaceable>T</replaceable>&gt;::create</methodname>(), with
      <replaceable>T</replaceable> being the &ref; or a &ptr; type that's
      calling it, and is the expected return type from
      <methodname>create</methodname>().
      By default, <classname>base</classname> gets typedef-ed to
      <classname>&ns;::ptrref_base</classname>, which defines the
      <classname>objfactory</classname> template class parameter with a
      static <methodname>create</methodname>() method that constructs a new
      object, for the &ref; or the &ptr;.
    </para>

    <para>
      &ref;'s and &ptr;'s <methodname>create</methodname>() method
      forwards its arguments to
      <methodname>base::objfactory&lt;<replaceable>T</replaceable>&gt;::create</methodname>().
      The default implementation,
      <methodname>&ns;::ptrref_base::objfactory&lt;<replaceable>T</replaceable>&gt;::create</methodname>(),
      constructs the object on the heap with <literal>new</literal>,
      and forwards the arguments to the object's constructor.
      In nearly all cases, it's sufficient to define a constructor in
      the reference-counted subclass of <classname>&ns;::obj</classname>,
      but it's possible to define a custom <classname>base</classname> with
      a <methodname>create</methodname>() that does something else.
    </para>

    <para>
      Reference-counted objects do not get explicitly
      <literal>delete</literal>d, as this is done by the reference-counting
      templates; and
      <methodname>create</methodname>() removes all the <literal>new</literal>s
      too. With <methodname>create</methodname>(), &ref;, and &ptr;, an application
      that uses &app; will not have any <literal>new</literal>s and
      <literal>delete</literal>s.
      Outside of <methodname>create</methodname>(), &app; itself
      has a grand total of
      two explicit <literal>new</literal>s, to allocate two low-level objects
      before most of its classes get initialized.
    </para>

    <note>
      <para>
	<methodname>create</methodname>() must be used to create
	subclasses of <classname>&ns;::obj</classname>. An explicit
	<literal>new</literal>, and assigning the result to an &reforptr;
	will not work. Assigning a native pointer, to an existing
	<classname>&ns;::obj</classname> subclass instance, to an &reforptr;
	is permitted, and has the expected result of incrementing the
	internal reference count.
      </para>
    </note>

    <section id="createrange">
      <title>Range-based iteration on reference-counted objects</title>

      <para>
	It can be convenient to use a reference-counted object that
	<methodname>begin</methodname>() and <methodname>end</methodname>(),
	<link linkend="dirwalk">&ns;::dirwalk</link>, as a range iterator:
      </para>

      <blockquote>
	<informalexample>
	  <programlisting>
&ns;::dirwalk etcdir=&ns;::dirwalk::create("/etc");

for (auto config: *etcdir)
{
    // ...
}</programlisting>
	</informalexample>
      </blockquote>

      <para>
	Note the need to dereference <varname>etcdir</varname> since, for
	all practical purposes, it's a pointer.
	<methodname>begin</methodname>() and
	<methodname>end</methodname>() gets implemented in the object it points
	to.
      </para>

      <note id="rangervalue">
	<para>
	  This shorter alternative seems intuitive, but it's actually
	  ill-formed:
	</para>

	<blockquote>
	  <informalexample>
	    <programlisting>
for (auto config: *&ns;::dirwalk::create("/etc"))
{
    // ...
}</programlisting>
	  </informalexample>
	</blockquote>

	<para>
	  The range iterator takes an rvalue reference. The reference from
	  <methodname>create</methodname>() goes out of scope and gets destroyed,
	  but the rvalue reference remains in scope, and gets invoked for the
	  <methodname>begin</methodname>() and the
	  <methodname>end</methodname>().
	  C++11 defines range iteration as equivalent to
	  (roughly speaking).
	</para>

	<blockquote>
	  <informalexample>
	    <programlisting>

auto &amp;&amp; range=*&ns;::dirwalk::create("/etc");

for (auto iter=range.begin(); auto != range.end(); ++iter)
{
    // ...
}</programlisting>
	  </informalexample>
	</blockquote>

	<para>
	  <function>&ns;::dirwalk::create()</function> instantiates a
	  reference-counted object. <literal>*</literal> dereferences, and
	  leaves it as an rvalue reference. The reference then gets destroyed,
	  at the end of the sequence point, and as it's the only reference to
	  the reference-counted object, it gets destroyed.
	  Meanwhile, the rvalue reference, to the destroyed object remains,
	  producing ill-formed results.
	</para>

	<para>
	  Rule of thumb to follow: when using the <literal>*</literal> operator
	  to dereference a reference-counted object for a container-based
	  range operation, the <literal>*</literal> operator should operate
	  on an lvalue, and never an rvalue.
	</para>
      </note>
    </section>
  </section>

  <section id="custombase">
    <title>Specifying a custom <classname>base</classname></title>

    <para>
      The following example uses a <methodname>create</methodname>() method to
      instantiate a new reference-counted object, with its initial pointer
      or reference:
    </para>

    <blockquote>
      <informalexample>
	<programlisting>
typedef &ns;::ref&lt;buttonObj&gt; button;

button b(button::create());

// ...

b-&gt;click();</programlisting>
      </informalexample>
    </blockquote>


    <para>
      &ref;'s and &ptr;'s <classname>base</classname> typedef actually
      comes from an optional second parameter to the &ref; and the &ptr;
      template class, which defaults to <classname>&ns;::ptrref_base</classname>.
      This can be overridden in two different ways. The first way is to
      specify an additional parameter to the template:
    </para>

    <blockquote>
      <informalexample>
	<programlisting>
class buttonBase;
class buttonObj;

typedef &ns;::ref&lt;buttonObj, buttonBase&gt; button;
typedef &ns;::ptr&lt;buttonObj, buttonBase&gt; buttonptr;

class buttonBase {

public:

    template&lt;typename ptrrefType&gt; class objfactory {
    public:

        static ptrrefType create()
        {
            // ...
        }
    };
    static const int default_width=50, default_height=50;
};</programlisting></informalexample></blockquote>

    <para>
      The second way is to
      <ulink url="&link-typedef-x--base-type-type;">specialize
	<classname>&ns;::base_type</classname> and define a
	<varname>type</varname> class member</ulink>:
    </para>

    <blockquote>
      <informalexample>
	<programlisting>
class buttonObj;

template&lt;&gt;
struct &ns;::base_type&lt;buttonObj&gt; {

    typedef buttonBase type;
};

typedef &ns;::ref&lt;buttonObj&gt; button;
typedef &ns;::ptr&lt;buttonObj&gt; buttonptr;


</programlisting>
      </informalexample>
    </blockquote>

    <para>
      Specializing <classname>&ns;::base_type</classname> in this manner
      ends up specifying the default second parameter to the
      &ref; and &ptr; templates (also &const_ref; and &const_ptr; too).
      With this specialization,
      <classname>&ns;::ref&lt;buttonObj&gt;</classname>
      and
      <classname>&ns;::ref&lt;buttonObj, buttonBase&gt;</classname>
      is the same type, with the second template parameter setting
      the &ref;'s or the &ptr;'s <varname>base</varname> member.
      This specialization also takes effect when
      <link linkend="refptrdeduction">constructing an &reforptr; from
	<varname>this</varname></link>.
    </para>

    <para>
      An &reforptr;'s <methodname>create</methodname>() method invokes
      <methodname>base::objfactory&lt;<replaceable>T</replaceable>&gt;::create</methodname>(), where
      <replaceable>T</replaceable> is either the &ref; or the &ptr; type.

      in this example, <classname>button::base</classname> gets typedef-ed to
      <classname>buttonBase</classname> instead of
      <classname>&ns;::ptrref_base</classname>, so invoking
      <methodname>button::create</methodname>() invokes the custom
      <methodname>create</methodname>() method that returns an &reforptr;,
      with
      <varname>button::base::default_width</varname> and
      <varname>button::base::default_height</varname> referencing the given
      definitions.
      In this manner, it's possible to define
      custom <classname>create</classname>() methods that construct new
      pointers or references in arbitrary ways, rather than just by invoking
      the corresponding object constructor.
    </para>

    <para>
      The above example also gives the general naming convention:
      <classname><replaceable>name</replaceable>Obj</classname> for the
      reference-counted object itself;
      <classname><replaceable>name</replaceable></classname> for the
      reference to the object, and
      <classname><replaceable>name</replaceable>ptr</classname> for the
      nullable reference pointer to the object, with the same class typedef-ed
      to
      <classname><replaceable>name</replaceable>::base</classname> and
      <classname><replaceable>name</replaceable>ptr::base</classname> .
    </para>

    <para>
      Sometimes it's convenient to keep the default variadic
      <methodname>create</methodname>(), and just supplement
      <classname>base</classname> with other stuff.
      Use the following design pattern to inherit the
      the default variadic implementation of
      <methodname>create</methodname>() into the base class:
    </para>

    <blockquote>
      <informalexample>
	<programlisting>
class buttonBase;
class buttonObj;

typedef &ns;::ref&lt;buttonObj, buttonBase&gt; button;
typedef &ns;::ptr&lt;buttonObj, buttonBase&gt; buttonptr;

class buttonBase : public &ns;::ptrref_base {

public:
    static const int default_width=50, default_height=50;
};</programlisting></informalexample></blockquote>

    <para>
      Here, <classname>buttonBase</classname> subclasses
      <classname>&ns;::ptrref_base</classname>, which is the default
      <classname>base</classname> of an &reforptr;, and inherits the
      default implementation of <classname>objfactory</classname>.
      For completeness, here's the actual definition of
      <classname>&ns;::ptrref_base</classname>:
    </para>

    <blockquote>
      <informalexample>
	<programlisting>
class ptrref_base {
public:

    template&lt;typename ptrrefType&gt; class objfactory {
    public:

        template&lt;typename... Args_t&gt;
        static inline ptrrefType
        create(Args_t &amp;&amp;...args)
        {
            return ptrrefType(new typename ptrrefType
                      ::obj_type(std::forward&lt;Args_t&gt;(args)...));
        }
    };
};</programlisting></informalexample></blockquote>

    <para>
      &ref; and &ptr; also define the <classname>obj_type</classname>
      member typedef to the reference-counted object type.
      <methodname>&ref;::create</methodname>() and
      <methodname>&ptr;::create</methodname>() forward their arguments to
      <methodname>base::objfactory&lt;<replaceable>T</replaceable>&gt;::create</methodname>(), where
      <replaceable>T</replaceable> is the &ref; or the &ptr; type.
    </para>
  </section>

  <section id="multinhobj">
    <title>Multiple inheritance and casting</title>

    <para>
	A subclass that inherits from two different reference-counted objects
	inherits a single <classname>&ns;::obj</classname> superclass, since
	it's virtually inherited:</para>

    <blockquote>
      <informalexample>
	<programlisting>
class widgetObj : virtual public &ns;::obj {

// ....

};

class containerObj : virtual public &ns;::obj {

// ....

};

class boxObj : public widgetObj, public containerObj {

// ....
};

typedef &ns;::ref&lt;widgetObj&gt; widget;
typedef &ns;::ref&lt;containerObj&gt; container;
typedef &ns;::ref&lt;boxObj&gt; box;

typedef &ns;::ptr&lt;widgetObj&gt; widgetptr;
typedef &ns;::ptr&lt;containerObj&gt; containerptr;
typedef &ns;::ptr&lt;boxObj&gt; boxptr;</programlisting>
      </informalexample>
    </blockquote>

    <para>
	This is the reason why <classname>&ns;::obj</classname> should always
	be inherited virtually.
      </para>

    <para>
      An &reforptr;
      to a subclass may be converted to an &reforptr; to its
      superclass. The opposite is also true: an &reforptr; to a superclass
      may be converted to an &reforptr; to a subclass, but only if the
      referenced object is actually an instance of the subclass, of course:
    </para>

    <blockquote>
      <informalexample>
	<programlisting>
widget wRef;
container cRef;

// ...

cRef=wRef;

// ...

wRef=cRef;</programlisting>
      </informalexample>
    </blockquote>

    <para>
      A runtime exception gets thrown if the
      pointer or the reference cannot be converted.
      Use <literal>dynamic_cast&lt;&gt;</literal> if it's unknown whether
      the superclass reference refers to an instance of a subclass:
    </para>

    <blockquote>
      <informalexample>
	<programlisting>
if (!wRef.null())
{
    widgetObj *wptr(&amp;*wRef);

    if (dynamic_cast&lt;boxObj *&gt;(wptr))
    {
       container cRef(wRef);

       // ....
    }
}</programlisting>
      </informalexample>
    </blockquote>

    <para>
      Conversion between an &reforptr; (source) to a different &reforptr;
      (destination) proceeds as follows. If the destination is a superclass
      of the source, the conversion uses a <literal>static_cast</literal>.
      Otherwise the conversion uses a <literal>dynamic_cast</literal> and
      thrown an exception if the conversion fails.
    </para>

    <para>
      A destination class can avoid the overhead of a
      <literal>dynamic_cast</literal> by defining a
      <methodname>cast_from</methodname>() class method that returns
      a plain pointer to the destination class with a pointer to a plain
      source class as a parameter:
    </para>

    <blockquote>
      <informalexample>
	<programlisting>
class aObj : virtual public &ns;::obj {

public:

	virtual D *getd() { return nullptr; }

};

class bObj : public aObj {
};

class dObj : public bObj {

public:

	static dObj *cast_from(aObj *a)
	{
		return a->getd();
	}

	dObj *getd() override { return this; }
};

// ...
&ns;::ref&lt;aObj&gt; return_a();

&ns;::ref&lt;dObj&gt; d=return_a();</programlisting>
      </informalexample>
    </blockquote>

    <para>
      Normally an attempt to convert an &ref; of <classname>aObj</classname>
      to <classname>dObj</classname> gets carried out via a
      <literal>dynamic_cast</literal>. Here, <classname>dObj</classname>
      defines a <methodname>cast_from</methodname> static class method that
      takes a pointer to an <classname>aObj</classname> and returns a
      <classname>DObj</classname>. This results in the
      <literal>dynamic_cast</literal> getting replaced by the
      <classname>cast_from</classname>() call.</para>

    <para>
      The intended use is to have <methodname>cast_from</methodname> invoke
      a virtual method in the source class. The base implementation in the
      source class returns a <literal>nullptr</literal> by default, with the
      destination class overriding and simply returning
      <literal>this</literal>. The end result is a good enough facsimile for a
      <literal>dynamic_cast</literal> that it ends up being used as a
      pinch-hitter.
    </para>

    <para>
      This design pattern replaces an otherwise expensive
      <literal>dynamic_cast</literal> with a much cheaper virtual function
      dispatch. The functionality of a full <literal>dynamic_cast</literal>
      isn't matched identically, but this should suffice for most common
      use cases.
    </para>
  </section>

  <section id="reffromthis">
    <title>Creating an &reforptr; from <varname>this</varname></title>

    <para>
      An &reforptr; can be constructed from a native object pointer.
      This is frequently used by class methods to create pointers or
      references to
      the <varname>this</varname> object:
    </para>

    <blockquote>
      <informalexample>
	<programlisting>
class widgetObj : virtual public &ns;::obj {

// ...

};

typedef &ns;::ref&lt;widgetObj&gt; widget;

// ...

void widgetObj::method()
{
    // ...

    widget myRef(this);

    // ...
}</programlisting>
      </informalexample>
    </blockquote>

    <para>
	This allows a class method to create an &reforptr; to the object
	pointed by <varname>this</varname>, so that it can be passed along
	to other objects or methods, for example. Note, however:
      </para>

    <note>
      <para>
	Creating an &reforptr;
	to <varname>this</varname> in the object's constructor
	<methodname>abort</methodname>()s. Consider the following scenario:
      </para>

      <itemizedlist>
	<listitem>
	  <para>
	    <methodname>create</methodname>() creates the object. The new
	    object's reference count does not get incremented from its initial
	    value of zero, to one, until the object gets fully constructed.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    With the initial reference count still zero, one
	    the constructors makes
	    an explicit &ref;&lt;<replaceable>classname</replaceable>&gt;(<varname>this</varname>)
	    creating a new &ref;. This increments the object's reference
	    count to one.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    This &ref; goes out of scope and gets destroyed, also before
	    the constructor finishes. This now decrements the reference count
	    back to zero. When an object's reference count goes to 0,
	    it gets destroyed. This is now happening before the object
	    is fully constructed. Even if that, by some miracle
	    of miracles, doesn't blow up, the remaining constructors continue
	    to execute, and eventually the original &ref; attempts to
	    increment what it thinks is the initial reference count, in the
	    object that's already destroyed.
	  </para>
	</listitem>
      </itemizedlist>

      <para>
	Undefined behavior is guaranteed here. The same holds true with
	creating an &ref; to an object from one of its destructors. The
	object's reference count is zero, and it's going to get destroyed
	no matter what, after all destructors are done. A new &ref;
	(or a &ns;::ptr, doesn't matter) to the object does not prevent that
	from happening. The end result is an &reforptr; to a destroyed object.
      </para>

      <para>
	For this reason, attempting to create an &reforptr; to
	<literal>this</literal> in its constructor or destructor immediately
	<function>abort</function>()s, to aid in debugging.
	It's true that it's technically possible to have everything be legal
	with a &reforptr; from <literal>this</literal> created in its
	constructor, as long as the object succesfully finishes its full
	construction. However, &appshort; takes the pessimistic view that
	this can't be guaranteed (on the assumption that an exception can
	get thrown at any time), and prevents this from happening.
	Constructing an &reforptr; from <literal>this</literal> in the
	constructor is a bad idea.
      </para>

      <para>
	Technical note:
	it's not really true that the a newly-constructed object starts
	with a reference count of 0. Internally, &appshort; sets the
	initial reference count to -1, and resets it to 0 just before
	<methodname>create</methodname>() creates and returns the first
	&reforptr;, which immediately updates it to 1. The reference
	count of -1 gets used to detect an attempt to create an &reforptr;
	in a constructor (or the destructor).
      </para>

      <para>
	For this reason, new reference-counted objects must always get
	created with <methodname>create</methodname>() in order to
	properly initialize the new object's reference count. Manually
	instantiating the object with <literal>new</literal>, and
	assigning it to an &reforptr;, also aborts the program.
      </para>
    </note>

    <section id="refptrdeduction">
      <title>Using deduction guides with an &reforptr;</title>


      <blockquote>
	<informalexample>
	  <programlisting>
class buttonObj : virtual public &ns;::obj {

// ...

     void clicked();
};

void buttonObj::clicked()
{
auto r=&ns;::ref(this);

};</programlisting></informalexample></blockquote>

      <para>
	A natural deduction guide for an &reforptr; (also &const_ref; and
	&const_ptr; too) simplifies creating an &reforptr; from
	<varname>this</varname> (or from some other native pointer).
	Note that this results in the
	<link linkend="custombase">default <classname>base</classname></link>
	<literal>typedef</literal> of
	<classname>&ns;::ptrref_base</classname>, for the constructed
	reference or a pointer. However the deduction guide uses the
	<classname>&ns;::base_type</classname> specialization, if one is
	available:
      </para>

      <blockquote>
	<informalexample>
	  <programlisting>
class buttonObj : virtual public &ns;::obj {

// ...

     void clicked();
};

template&lt;&gt;
struct &ns;::base_type&lt;buttonObj&gt; {

    typedef buttonBase type;
};

void buttonObj::clicked()
{
auto r=&ns;::ref(this);

};</programlisting></informalexample></blockquote>

      <para>
	Because this specialization overrides the second template parameter
	to an &reforptr;, this constructs a
	<classname>&ns;::ref&lt;buttonObj, buttonBase&gt;</classname>.
      </para>
    </section>
  </section>

  <section id="multinherit">
    <title>Multiple inheritance with reference-counted objects</title>

    <blockquote>
      <informalexample>
	<programlisting>
class ButtonRendererObj: virtual public &ns;::obj {

// ...

};

class InputInterfaceObj: virtual public &ns;::obj {

// ...

};

class ButtonObj : public ButtonRenderObj, public InputInterfaceObj {

// ...

};

&ns;::ptr&lt;ButtonRendererObj>&gt; button;

&ns;::ptr&lt;InputInterfaceObj>&gt; inputp;

// ...

inputp=button;</programlisting>
      </informalexample>
    </blockquote>

    <para>
      Multiple inheritance works as expected. Virtual inheritance of the
      <classname>&ns;::obj</classname> superclass results in the derived
      object virtually inheriting a single instance of it, and references
      to any member of the inheritance hierarchy are convertible to any
      other member of the inheritance hierarchy.
    </para>
  </section>

  <section id="privinherit">
    <title>Private inheritance of reference-counted objects</title>

    <para>
      <classname>&ns;::obj</classname> must be publicly inherited:
    </para>

    <blockquote>
      <informalexample>
	<programlisting>
class ButtonRendererObj: virtual private &ns;::obj {

// ...

};</programlisting>
      </informalexample>
    </blockquote>

    <para>
      This won't work because
      <classname>&ns;::ref&lt;ButtonRendererObj&gt;</classname> needs to access
      the <classname>&ns;::obj</classname> superclass. For the same reason,
      a reference-counted object cannot have non-public inheritance, either.
    </para>

    <blockquote>
      <informalexample>
	<programlisting>
class ButtonRendererObj: virtual public &ns;::obj {

// ...

};

class ButtonObj : private ButtonRendererObj {

// ...

	};</programlisting>
      </informalexample>
    </blockquote>

    <para>
      Explicitly inheriting from <classname>&ns;::obj</classname> allows
      references to work, but with a caveat:
    </para>

    <blockquote>
      <informalexample>
	<programlisting>
class ButtonRendererObj: virtual public &ns;::obj {

// ...

public:
     void doButtonRender();

};

class ButtonObj : private ButtonRendererObj, virtual public &ns;::obj {

// ...

	};</programlisting>
      </informalexample>
    </blockquote>

    <para>
      References to either class now works as expected,
      but the private inheritance isn't really private:
    </para>

    <blockquote>
      <informalexample>
	<programlisting>
&ns;::ptr&lt;ButtonObj&gt; buttonp;

// ...

buttonp-&gt;doButtonRender(); // doesn't work, private inheritance.


&ns;::ref&lt;ButtonObj&gt;(&ns;::ref&lt;&ns;::obj&gt;(buttonp))-&gt;doButtonRender(); // this works</programlisting>
      </informalexample>
    </blockquote>

    <para>
      Both classes publicly inherit from <classname>&ns;::obj</classname>,
      so a pointer or a reference to one can be dynamically casted through
      <classname>&ns;::obj</classname> to the other one.
    </para>

    <para>
      Careful usage of private inheritance, and friend declarations with
      &ptr;, allows truly private inheritance
      of reference-counted objects. But that adds extra complexity, and the
      basic approach strikes a reasonable balance. Private inheritance is
      voluntarily enforced, unless a long detour gets taken to work around
      it; and this back-door can be useful
      for out-of-band situations, like automated
      regression tests.
    </para>
  </section>

  <section id="refptrhash">
    <title>Comparing &ref;s and &ptr;s</title>

    <blockquote>
      <informalexample>
	<programlisting>
std::map&lt;&ns;::ref&lt;myObj&gt;, int&gt; ref_map;

#include &lt;&ns;/refptrhash.H&gt;

std::unordered_map&lt;&ns;::ref&lt;myObj&gt;, int&gt; ref_unordered_map;</programlisting>
      </informalexample>
    </blockquote>

    <para>
      &ref;s and &ptr;s support comparison operators.
      &ref; (and &ptr;s and <classname>&ns;::const_ref</classname>s
      and <classname>&ns;::const_ref</classname>s) can be compared with
      each other (if the types match) for equality, or strict weak ordering.
    </para>

    <para>
      For unordered containers, use
      <filename>refptrhash.H</filename> header file to define the
      required specializations of <classname>std::hash</classname>.
    </para>
  </section>

  <section id="isa">
    <title><methodname>isa</methodname>()</title>

    <blockquote>
      <informalexample>
	<programlisting>

typedef &ns;::ref&lt;buttonObj&gt; button;

typedef &ns;::ref&lt;windowObj&gt; window;

bool is_a_button(const window &amp;w)
{
    return w->isa&lt;button&gt;();
}</programlisting>
      </informalexample>
    </blockquote>

    <para>
      The <methodname>isa</methodname>() <classname>&ns;::obj</classname>
      method takes an &reforptr; template parameter, and returns true if
      an &reforptr; to this object is capable of getting dynamically casted
      to the template &reforptr;.
    </para>

    <para>
      This is equivalent to <quote>dynamic_cast&lt;buttonObj *&gt;(&amp;*w)</quote>,
      but with a clean syntax.
    </para>
  </section>

  <section id="weakptr">
    <title>Weak pointers</title>

    <para>
      When all pointers and references to an object go out of scope, the
      object gets automatically destroyed. An ordinary pointer can be
      converted to a weak pointer. When all ordinary pointers and
      and references go out
      of scope, the object gets destroyed even if there's a weak pointer to the
      object:
      </para>

    <blockquote>
      <informalexample>
	<programlisting>
#include &lt;&ns;/obj.H&gt;
#include &lt;&ns;/ref.H&gt;
#include &lt;&ns;/weakptr.H&gt;

class widgetObj : virtual public &ns;::obj {

// ...

};

typedef &ns;::ref&lt;widgetObj&gt; widget;

typedef &ns;::ptr&lt;widgetObj&gt; widgetptr;

typedef &ns;::weakptr&lt;widgetptr&gt; weakwidget;

// ...

widget w{widget::create()};

// ...

weakwidget weakw=w.weaken();

// ...

widgetptr origw=weakw.getptr();

if (!origw.null())
{
    // ...
}</programlisting>
      </informalexample>
    </blockquote>

    <para>
      <methodname>weaken</methodname>() creates a
      <ulink url="&link-x--weakptr;"><classname>weakptr</classname></ulink>,
      a weak pointer.
      Alternatively, its constructor can be invoked directly, but note that
      the template's constructor
      takes a &ptr; and not an &ref;, but both &ptr;s and &ref;s have
      a <methodname>weaken</methodname>() method.
      The only method implemented by a
	<classname>weakptr</classname> is <methodname>getptr</methodname>(),
	which returns an ordinary, strong pointer to the underlying object,
	if it still exists.
	If all other existing references to the object previously went out of
	scope and the object got destroyed,
	<methodname>getptr</methodname>() returns an unbound reference.
      </para>

    <para>
	Like &ptr;, the
	implementation of <classname>weakptr</classname>
	is thread-safe, however see
	<link linkend="thrsafenote">important comments about thread safety of
	  references</link>.
    </para>
  </section>

  <section id="refptrtraits">
    <title>Reference and pointer traits</title>

    <blockquote>
      <informalexample>
	<programlisting>
	  #include &lt;&ns;/refptr_traits.H&gt;

	  class someClassObj;
	  class someBase;

	  typedef &ns;::ref&lt;someClassObj, someBase&gt; some_ref;

	  typedef &ns;::refptr_traits&lt;some_ref&gt;::ref_t ref_t;
	  typedef &ns;::refptr_traits&lt;some_ref&gt;::ptr_t ptr_t;
	  typedef &ns;::refptr_traits&lt;some_ref&gt;::const_ref_t const_ref_t;
	  typedef &ns;::refptr_traits&lt;some_ref&gt;::const_ptr_t const_ptr_t;


	  typedef &ns;::ref_cast&lt;some_ref&gt; ref_cast_t;
	  typedef &ns;::ptr_cast&lt;some_ref&gt; ptr_cast_t;</programlisting>
      </informalexample>
    </blockquote>

    <para>
      These template classes take an &reforptr; and replace it with
      another reference or a pointer to the same object (and base class).
      The
      <classname>&ns;::refptr_traits</classname>,
      <classname>&ns;::ref_cast</classname>, and
      <classname>&ns;::ptr_cast</classname> templates are specialized for
      a &ref;, &ptr;, &const_ref;, and a &const_ptr;.
    </para>

    <para>
      <classname>&ns;::refptr_traits</classname> is a class with four
      member types:
      <classname>ref_t</classname>,
      <classname>ptr_t</classname>,
      <classname>const_ref_t</classname>, and
      <classname>const_ptr_t</classname>. These types are a
      &ref;, &ptr;, &const_ref;, and a &const_ptr; to the same class
      (and base class) as the template parameter.
    </para>

    <para>
      A <classname>&ns;::ref_cast</classname> of a &ref; or a &ptr;
      results in a &ref; to the same class (and base class).
      A <classname>&ns;::ref_cast</classname> of a &const_ref; or a
      &const_ptr;
      results in a &const_ref; to the same class (and base class).
      A <classname>&ns;::ptr_cast</classname> of a &ref; or a &ptr;
      results in a &ptr; to the same class (and base class).
      A <classname>&ns;::ptr_cast</classname> of a &const_ref; or a
      &const_ptr;
      results in a &const_ptr; to the same class (and base class).
    </para>

    <section id="refcollection">
      <title>Constructing a collection of references</title>

      <para>
	Using &ref;, where possible, is better than &ptr;.
	&ref; proves, by contract, that it's a not a <literal>nullptr</literal>.
	&ref;'s only disadvantage is that it's not possible to declare
	an &ref; without an actual object to reference. &ref;
	does not have a default constructor, by definition.
      </para>

      <para>
	It's quite often to have a situation that involves construction
	of a bunch of &ref;s. However, each one's construction is rather
	involved. Perhaps, for some reason, some of the &ref;'s can only
	be constructed in a different, inner scope, then saved outside of their
	construction scope.
      </para>

      <para>
	A common design pattern is to initially declare &ptr;s, construct and
	define each one of them when needed, then permanently save each one
	as a &ref;. When all objects
	are constructed they get all converted to &ref;s.
	The <filename>refcollection.xsl</filename> stylesheet generates
	a framework for this kind of a design pattern. The stylesheet
	converts an <acronym>XML</acronym> header file into a C++
	class declaration. The simple <acronym>XML</acronym> looks like this:
      </para>

      <blockquote>
	<informalexample>
	  <programlisting><![CDATA[
<collection>
  <name>mycollection</name>
  <ref>
    <type>intval_ref</type>
    <name>a</name>
  </ref>
  <ref>
    <type>constintval_ref</type>
    <name>b</name>
  </ref>
</collection>]]></programlisting>
	</informalexample>
      </blockquote>

      <para>
	This file gets processed by the stylesheet processor, such as
	<command>xsltproc</command>:
      </para>

      <blockquote>
	<informalexample>
	  <programlisting>
# $datadir/libcxx is installed by the library

xsltproc $datadir/libcxx/refcollection.xsl refcollection.xml &gt;refcollection.H
</programlisting>
	</informalexample>
      </blockquote>

      <para>
	The resulting header file declares the following classes:
      </para>
      <blockquote>
	<informalexample>
	  <programlisting>
struct mycollectionptr {
	&ns;::ptr_cast&lt;intval_ref&gt; a;
	&ns;::ptr_cast&lt;constintval_ref&gt; b;
};

struct mycollection {
	intval_ref a;
	constintval_ref b;

	mycollection(const mycollectionptr &amp;p)
	: a(p.a),
	  b(p.b)
	{}
};
</programlisting>
	</informalexample>
      </blockquote>

      <para>
	And the typical usage looks like this:
      </para>
      <blockquote>
	<informalexample>
	  <programlisting>
#include &lt;&ns;/refptr_traits.H&gt;

class intvalObj : virtual public &ns;::obj {

// ...
};

typedef &ns;::ref&lt;intvalObj&gt; intval_ref;

typedef &ns;::const_ref&lt;intvalObj&gt; constintval_ref;

#include "refcollection.H"

// ...

class refcollectionObj : virtual public &ns;::obj, public mycollection {

public:
     using mycollection::mycollection;
};

// ============

mycollectionptr ptrs;

// Long-winded code that ends up initializing ptrs.a and ptrs.b

auto newobj=&ns;::ref&lt;refcollectionObj&gt;::create(ptrs);

// So, now, newobj-&gt;a and newobj-&gt; are ready for action, and are
// ordinary references.
	  </programlisting>
	</informalexample>
      </blockquote>

      <para>
	The basic approach is to declare a structure with nullable
	pointer references, which get initialized on their own schedule.
	Afterwards, the collection of &ptr;s gets passed to a constructor
	of equivalent &ref;s, to convert them all to references, going
	forward.
      </para>

      <para>
	A <filename>Makefile.am</filename> macro assists in creating
	an appropriate build rule (see <xref linkend="optgenautomake" />
	for more information on &app;'s integration with
	<application>automake</application> and
	<application>autoconf</application>):
      </para>

      <blockquote>
	<informalexample>
	  <programlisting>
@LIBCXX_AM@

# ...

$(call REFCOLLECTION_GEN,refcollection.H,$(srcdir)/refcollection.xml)
</programlisting>
	</informalexample>
      </blockquote>

      <para>
	This macro creates a rule to build <filename>refcollection.H</filename>
	from the <filename>refcollection.xml</filename>
	source using the stylesheet.
	The structure of the <acronym>XML</acronym> is as follows:
      </para>

      <itemizedlist>
	<listitem>
	  <para>
	    The top level element is a <tag class='element'>collection</tag>
	    which contains a <tag class='element'>name</tag> and a list
	    of
	    <tag class='element'>ref</tag>s.
	  </para>

	  <para>
	    The <tag class='element'>name</tag> gives the name of the classes
	    generated by the stylesheet. The stylesheet generates a header
	    file that declares a class whose name is
	    <quote><tag class='element'>name</tag></quote>, containing
	    the <tag class='element'>ref</tag>s, and
	    <quote><tag class='element'>name</tag>ptr</quote>, containing
	    the &ptr; equivalent of each <tag class='element'>ref</tag>.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Each <tag class='element'>ref</tag> creates a member of both
	    <quote><tag class='element'>name</tag></quote> and
	    <quote><tag class='element'>name</tag>ptr</quote> classes.
	    <tag class='element'>ref</tag> contains
	    a <tag class='element'>name</tag> that gives the name of the
	    member, with
	    <tag class='element'>type</tag> giving the member's type.
	  </para>

	  <para>
	    The specified
	    <tag class='element'>type</tag> must be an &ref; or an
	    &const_ref;.
	  </para>
	</listitem>
      </itemizedlist>
    </section>
  </section>
  <section id="ondestroy">
    <title>Destructor callbacks and mcguffins</title>

    <para>
      It is possible to set up one or more <quote>callbacks</quote> that get
      invoked
      when some subclass of <classname>&ns;::obj</classname>,
      some <quote>mcguffin</quote>, gets destroyed after the last &reforptr;
      to the mcguffin goes out of scope.
      This <quote>callback</quote> is some method in an instance of a different,
      otherwise unrelated, class. The method gets invoked whenever the
      first class gets destroyed. Here, the first class is called a
      <quote>mcguffin</quote>. This name comes from
      the film director Alfred Hitchcock who used it
      to describe some minor prop or gadget that is of little inherent value,
      but is responsible for driving the major plot of a movie.
      (Although <quote>macguffin</quote> is the more popular spelling, I like
      the <quote>mcguffin</quote> spelling better, and I'm the one
      writing this documentation).
    </para>

    <para>
      A mcguffin is some
      <link linkend="refobj">reference-counted object</link>
      whose own implicit existence has some inherent purpose, and defines some
      part of its functionality, loosely speaking.
      Consider a typical situation of a thread sending some kind of a message
      to another thread. The first thread wants to know when the second thread
      processed this message.
    </para>

    <para>
      You can write and implement an acknowledgement mechanism of some kind,
      but this quickly gets complicated. What if, for
      example, the second thread ended
      normally, but before it had a chance to process the message? You'll
      have to handle that eventuality too. In most non-trivial situations
      there will be other ways for things to go off the rails.
    </para>

    <para>
      A mcguffin-oriented approach is simpler. The message to a thread
      is some kind of an object, which serves double-duty as a mcguffin.
      When the message gets received
      by the thread, processed, and discarded, the last reference to the
      message object goes out of scope and the mcguffin gets destroyed.
      If the thread stops, presumably its message queue, together with all
      of its messages, also gets destroyed. In all cases, the message object
      gets destroyed. The message object is a mcguffin, so its destructor
      callbacks gets invoked in all cases.
    </para>

    <para>
      A mcguffin may be a very distinguished class on its own merits. It might
      have many methods and members of its own; but it's a mcguffin because
      it exists, and for no other reason.
    </para>

    <para>
      A mcguffin can have more than one destructor callback.
      All destructor callbacks get invoked, one at a time, when
      the last &reforptr; to the mcguffin, a
      <link linkend="refobj">reference-counted object</link> goes out of scope
      and
      the object gets destroyed. The destructor callbacks get invoked
      immediately after the object's destructor returns and the object
      gets destroyed.
      Once invoked, each destructor callback does whatever it wants to do.
      The callbacks get invoked by whichever thread destroyed the last
      reference to the object, not necessarily the
      same thread that created it!
    </para>

    <para>
      By the time the destructor callbacks get called, the mcguffin is already
      destroyed, and the destructor callback has no means to access it. But
      that's fine, the object's existence was what made it a mcguffin, and
      now the destructor callbacks get invoked because the object got
      destroyed.
    </para>

    <blockquote>
      <informalexample>
	<programlisting>
#include &lt;&ns;/ref.H&gt;
#include &lt;&ns;/obj.H&gt;

class mcguffinObj : virtual public &ns;::obj {

// ...

};

auto mcguffin=&ns;::ref&lt;mcguffinObj&gt;::create();

// ...
myobj-&gt;ondestroy([]
   {

// ...

   });</programlisting>
      </informalexample>
    </blockquote>

    <para>
      The above example attaches a destructor callback to
      an instance of a <classname>mcguffinObj</classname>. This
      class may have its own
      methods, or serve some particular purpose that's unrelated to its
      role as a mcguffin. The above example leaves its methods unspecified.
      They don't matter. It's a mcguffin.
    </para>

    <para>
      For a
      <quote>pure</quote> mcguffin, the destructor callback
      gets attached to a plain
      <classname>&ns;::ref&lt;&ns;::obj&gt;</classname>.
      An <classname>&ns;::obj</classname> is nothing more than the base class
      for reference-counted objects, and a mere reference to this object
      has no other functionality, except serving as a convenient mcguffin
      for any occasion.
    </para>

    <para>
      See the <ulink url="&link-x--ptr;">&ptr;
      documentation</ulink> for more information on destructor callbacks.
    </para>

    <note id="destroyednoexcept">
      <para>
	Destructor callbacks should not throw exceptions, because
	it essentially becomes a part of
	the mcguffin's destructor, and cannot throw any exceptions.
	All <link linkend="exceptions">exceptions</link> must be caught.
      </para>
    </note>

    <section id="destructorcallback">
      <title>A basic destructor callback</title>

      <para>
	<ulink url="&link-typedef-x-destroy-callback;"><classname>&ns;::destroy_callback</classname></ulink>
	is a simple elementation of a common design pattern where some
	mcguffin's destruction does not itself takes any immediate action.
	Rather, at some point later, a check is made whether the object is
	already destroyed. If not, wait for its destruction.
      </para>

      <blockquote>
	<informalexample>
	  <programlisting>
#include &lt;&ns;/destroy_callback.H&gt;

&ns;::destroy_callback cb=&ns;::destroy_callback::create();

// ...

&ns;::ref&lt;&ns;::obj&gt; mcguffin;

mcguffin-&gt;ondestroy([cb] { cb->destroyed(); });

// ...

cb->wait();</programlisting>
	</informalexample>
      </blockquote>

      <para>
	This subclass implements a
	<methodname>wait</methodname>(), that waits indefinitely until
	its <methodname>destroyed</methodname>() gets invoked, presumably
	by another thread.
	<methodname>wait</methodname>() returns immediately
	if <methodname>destroyed</methodname>() was already
	invoked.
      </para>

      <note>
	<para>
	  <classname>&ns;::destroy_callback</classname> is designed
	  for simple one-off situations involving a single mcguffin.
	  It's your responsibility to attach it as a destructor callback to
	  at least one object, before invoking
	  <methodname>wait</methodname>(). If it's not been
	  <methodname>ondestroy</methodname>()ed anywhere, its
	  <methodname>destroyed</methodname>() never gets invoked, and
	  <methodname>wait</methodname>() waits forever.
	</para>
      </note>
    </section>

    <section id="ondestroyguard">
      <title>A destructor callback guard</title>

      <para>
	A
	<ulink url="&link-x--destroy-callbackBase--guard;"><classname>&ns;::destroy_callback::base::guard</classname></ulink>
	is an object meant to be instantiated on the stack, or as a class
	member.
	Its destructor waits until other objects placed in its care get
	destroyed, before the destructor itself returns:
      </para>

      <blockquote>
	<informalexample>
	  <programlisting>
void run()
{
    &ns;::destroy_callback::base::guard guard;

    &ns;::ref&lt;&ns;::obj&gt; mcguffin;

    guard(mcguffin);

// ...
}</programlisting>
	</informalexample>
      </blockquote>

      <para>
	When <function>run</function>()'s scope exits, its auto-scoped objects
	get destroyed in reverse order of declaration. But even after this
	<varname>mcguffin</varname> gets destroyed, other references to the
	mcguffin object might exist somewhere else, and/or used by other
	threads.
      </para>

      <para>
	Use this guard object when you want to wait for these mcguffins to
	really go out of scope and get destroyed. The guard object's destructor
	waits indefinitely until the guarded objects gets destroyed, if they're
	not destroyed already.
      </para>

      <para>
	More than one object can be guarded. The guard's
	<function>operator()</function> attaches a destructor callback to the
	mcguffin, and the guard's own destructor waits until all attached
	destructor callbacks get invoked, if they're not already invoked.
      </para>

      <para>
	The guard's
	<function>operator()</function> is a template function that returns
	the same &ref; that was passed to it. That makes it possible to do
	something like this:
      </para>

      <blockquote>
	<informalexample>
	  <programlisting>
void run()
{
    &ns;::destroy_callback::base::guard guard;

    start_timer(guard(&ns;::ref&lt;&ns;::obj&gt;::create()));

// ...
}</programlisting>
	</informalexample>
      </blockquote>

      <para>
	<function>start_timer</function>() is some external function that takes
	a mcguffin as an argument. The mcguffin is no longer needed after
	invoking it, and <function>run</function>() has no further use for it;
	and no more references to the mcguffin should remain,
	<function>start_timer</function>() owns it entirely.
	Here, guard's <function>operator()</function> does its job, returns
	whatever &ref; it got, which gets subsequently passed to
	<function>start_timer</function>().
      </para>

      <para>
	Subsequently, when <varname>guard</varname> goes out of scope, it
	waits for the mcguffin to get destroyed, wherever it is.
      </para>

      <note>
	<para>
	  <classname>&ns;::destroy_callback::base::guard</classname>
	  does not implement copy contructors or assignment operators.
	  It should always be instantiated either on the stack, or as a
	  class member.
	</para>
      </note>

      <para>
	<ulink url="&link-x--destroy-callbackBase--guard-object--ref--objClass--baseClass----;"><classname>&ns;::destroy_callback::base::guard_object</classname></ulink>
	is a convenient template to instantiate a guard for a single
	&ref;.
      </para>

      <blockquote>
	<informalexample>
	  <programlisting>
typedef &ns;::ref&lt;widgetObj&gt; widget;

class containerObj : virtual public &ns;::obj {

    &ns;::destroy_callback::base::guard_object&lt;widget&gt; title;

// ...
};

// ...
containerObj::containerObj() : title(widget::create())
{
// ...

   title-&gt;method();
}</programlisting>
	</informalexample>
      </blockquote>
      <para>
	<classname>&ns;::destroy_callback::base::guard_object</classname>'s
	template parameter must be an &ref;.
	<classname>&ns;::destroy_callback::base::guard_object</classname>
	declares a subclass of this &ref;, that's privately guarded.
	When <classname>&ns;::destroy_callback::base::guard_object</classname>
	goes out of scope and gets destroyed, if there are any other &ref;s
	or &ptr;s
	to the same object,
	<classname>&ns;::destroy_callback::base::guard_object</classname>
	waits until all other &ref;s and &ptr;s go out of scope and gets
	destroyed.
	<classname>&ns;::destroy_callback::base::guard_object</classname>'s
	destructor does not return until the referenced object's destructor
	returns.
      </para>
      <para>
	<classname>&ns;::destroy_callback::base::guard_object</classname>
	inherits
	<methodname>*</methodname>() and
	<methodname>-&gt;</methodname>() operators from the underlying
	&ref;, so that it can be used just like one. Although the
	guard object itself is not copy-constructible or assignable, the
	&ref; can be copied and passed around (with all copies required to be
	destroyed, before the guard's destructor returns).
      </para>
    </section>

    <section id="ondestroyrevocable">
      <title>Revocable destructor callbacks</title>

      <para>
	Attaching an ordinary destructor callback to a mcguffin is
	an irrevocable act. The destructor callback gets attached, and it
	gets invoked whenever the mcguffin ends up getting destroyed.
      </para>

      <para>
	Instead of invoking some mcguffin's <methodname>ondestroy</methodname>()
	method to attach a destructor callback to the mcguffin,
	construct an
	<ulink url="&link-typedef-x-ondestroy;"><classname>&ns;::ondestroy</classname></ulink>
	class instance:
      </para>

      <blockquote>
	<informalexample>
	  <programlisting>
#include &lt;&ns;/ondestroy.H&gt;

class mcguffinObj : virtual public &ns;::obj {

// ...

};

&ns;::ref&lt;mcguffinObj&gt; mcguffin=&ns;::ref&lt;mcguffinObj&gt;::create();

auto ondestroy_hook=&ns;::ondestroy::create([]
                  {
                        // ...
                  }, mcguffin, true);

// ...

ondestroy_hook-&gt;cancel();</programlisting>
	</informalexample>
      </blockquote>

      <para>
	The destructor callback lambda stays attached
	to its mcguffin until <classname>&ns;::ondestroy</classname>'s
	<methodname>cancel</methodname>() gets invoked. If the mcguffin is
	not destroyed by the time
	<methodname>cancel</methodname>() gets invoked,
	the destructor callback does not get invoked as part of the mcguffin's
	eventual destruction. If the mcguffin is
	already destroyed, and its destructor callbacks were already invoked,
	<methodname>cancel</methodname>() has no effect.
      </para>

      <para>
	<classname>&ns;::ondestroy</classname> itself is a reference to
	a reference-counted object, that can be freely passed around or copied.
	If the last parameter to
	<methodname>&ns;::ondestroy::create</methodname> is <literal>true</literal>,
	<methodname>cancel</methodname>() gets automatically invoked when
	the <classname>&ns;::ondestroy</classname>-referenced instance itself
	goes out of scope and gets destroyed. With <literal>false</literal>,
	when <classname>&ns;::ondestroy</classname> gets destroyed the
	destructor callback becomes permanent.
      </para>

      <para>
	If another thread is already running a just-destroyed object's
	callbacks, invoking <methodname>cancel</methodname>() explicitly
	blocks until the object's callbacks return.
	An explicit <methodname>cancel</methodname>()'s contract is that the
	destructor callback's
	<methodname>destroyed</methodname>() can never get called after
	<methodname>cancel</methodname>() returns.
	A <methodname>cancel</methodname>() that's automatically invoked, when
	<classname>&ns;::ondestroy</classname> goes out of scope and gets
	destroyed, does not block if another thread is executing the object's
	destructors.
      </para>

      <para>
	This is to allow an <classname>&ns;::ondestroy</classname> to go out
	of scope and get destroyed as a
	direct or an indirect result of the same object's destructor
	callback getting invoked. Otherwise, this ends up deadlocking the
	thread with itself: something is executing the object's destructor
	callbacks, and <classname>&ns;::ondestroy</classname>'s destructor
	needs to wait for the callback to return, but that can't happen until
	the destructor itself returns.
      </para>
    </section>

    <section id="onanydestroy">
      <title>Invoking a destructor callback when any of several objects gets destroyed</title>

      <blockquote>
	<informalexample>
	  <programlisting>
#include &lt;&ns;/ondestroy.H&gt;

// ...

std::list&lt;&ns;::ref&lt;&ns;::obj&gt; &gt; objects;

&ns;::on_any_destroyed([]
                   {
                      // Something was destroyed
                   }, objects.begin(), objects.end());</programlisting>
	</informalexample>
      </blockquote>

      <para>
	<methodname>&ns;::on_any_destroyed</methodname>() invokes a lambda
	when any one of several objects gets destroyed. Its parameters are
	a lambda to invoke, and a
	a beginning and an ending input iterator for a sequence of references
	to reference-counted object class instances.
      </para>

      <para>
	<methodname>&ns;::on_any_destroyed</methodname>() results in the lambda
	getting invoked when
	any of the objects in the sequence go out of scope and gets destroyed.
	The lambda callback gets invoked only once; for all
	practical matters, for the first object in the sequence that goes out
	of scope and gets destroyed. Subsequent destruction of other objects
	in the sequence does not result in
	the lambda getting invoked on their behalf.
      </para>

      <para>
	The input sequence is expected to produce strong &ref;s only. However,
	it's an arbitrary input sequence. Once an &ref; has been iterated over,
	it is no longer in scope, and, with a custom input iterator, its
	possible that it can get destroyed. If so, it's possible that
	the lambda gets called even before
	<methodname>&ns;::on_any_destroyed</methodname>() returns.
      </para>

      <para>
	The lambda also gets called, prior to
	<methodname>&ns;::on_any_destroyed</methodname>() returning in the event
	that the iterators define an empty input sequence.
	<methodname>&ns;::on_any_destroyed</methodname>() works by attaching
	an <link linkend="ondestroyrevocable"><methodname>&ns;::ondestroy</methodname></link>()
	callback to all of the objects in the sequence to a mcguffin that
	invokes the lambda, with the first
	<link linkend="ondestroyrevocable"><methodname>&ns;::ondestroy</methodname></link>()
	call releasing the mcguffin, whose destructor invokes the lambda.
	If the iterator sequence is empty, the mcguffin goes out of scope
	immediately, prior to
	<methodname>&ns;::on_any_destroyed</methodname>() returning.
      </para>
    </section>
  </section>

  <section id="destroycallbackwait4">
    <title>Waiting for a cascading destructor</title>

    <para>
      An <ulink url="&link-typedef-x-destroy-callback-wait4;"><classname>&ns;::destroy_callback_wait4</classname></ulink>
      implements a way for a thread that destroys one object to stop, and then
      wait for some other object to get destroyed too, presumably by another
      thread.
      A typical use case is when a thread constructs an object, and this
      object constructs a reference to the second object. The first object
      is considered to be the owner of the second object, but the second
      object can also be used by other threads, and when the first object
      goes out of scope and gets destroyed, it's necessary to also wait for
      any other fleeting references to the second object to go out of scope
      so that the second object gets destroyed too.
    </para>

    <para>
      This is similar to a
      <link linkend="ondestroyguard">guard object</link>, except that the
      guard object gets instantiated on the stack, and waits for all guarded
      objects to get destroyed, when the guard object goes out of scope.
      <classname>&ns;::destroy_callback_wait4</classname> is a reference
      to a <link linkend="refobj">reference-counted object</link>. Once
      it gets created and installed, explicit references to the object are
      no longer needed. A reference remains to it, since it's installed as a
      destructor callback to some other object. Whichever thread ends up
      destroying it, invokes the destructor callback, which then waits for
      the second object to get destroyed, before proceeding.
    </para>

    <blockquote>
      <informalexample>
	<programlisting>
#include &lt;&ns;/destroy_callback_wait4.H&gt;
#include &lt;&ns;/threads/run.H&gt;

class parentObj : virtual public &ns;::obj {

    class childObj;

public:
    parentObj()
    {
    }

    void start_child()
    {
        auto child=&ns;::ref&lt;childObj&gt;::create();

        addOnDestroy(&ns;::destroy_callback_wait4::create(child));

        &ns;::run(child);
    }
};</programlisting>
      </informalexample>
    </blockquote>

    <para>
      <classname>&ns;::destroy_callback_wait4</classname>'s constructor
      takes a reference to a reference-counted object.
      Its <methodname>destroyed</methodname>() method, when and if it gets
      invoked, waits for the object's destruction, if it's not already
      destroyed.
      After the <classname>&ns;::destroy_callback_wait4</classname> gets
      installed as a parent's destructor callback, once the parent object
      goes out of scope and gets destroyed, if, previously, a child
      object got started, parent's destruction automatically waits for the
      child thread to exit, and for any other references to the child object
      to also go out of scope, and get destroyed, before the destruction
      of the parent object fully concludes.
    </para>

    <para>
      Here's a slight variation on this theme:
    </para>

    <blockquote>
      <informalexample>
	<programlisting>
        &ns;::run(child)->addOnDestroy(&ns;::destroy_callback_wait4::create(child));</programlisting>
      </informalexample>
    </blockquote>

    <para>
      By installing a <classname>&ns;::destroy_callback_wait4</classname>
      destructor callback on the thread's return value object, this has
      the effect of only waiting until the thread finishes execution.
      With no other references to the thread return value object, it goes out
      of scope and gets destroyed when the thread finishes, even if the child
      thread object remains in scope due to other references.
    </para>

    <note>
      <para>
	Any thread where the last reference to the object
	that goes out of scope ends up invoking the destructor callback
	and waiting indefinitely for the other object to get destroyed, by some
	other thread. Threads and objects should be carefully designed, so that
	can actually happen, in pradtice.
      </para>
    </note>

    <para>
      Internally, <classname>&ns;::destroy_callback_wait4</classname> uses
      <link linkend="destructorcallback"><classname>&ns;::destroy_callback</classname></link>,
      which is where it gets the class name from.
    </para>
  </section>

  <section id="weakcontainers">
    <title>Weak containers</title>

    <para>
      &app; implements several variations of &stl; containers that store
      <link linkend="weakptr">weak pointers</link>, with an additional
      aspect that
      the weak pointer gets removed from the container automatically when its
      referenced object goes out of scope and gets destroyed.
    </para>

    <para>
      The container itself is an ordinary
      <link linkend="refobj">reference-counted object</link> (which can
      certainly have its own weak pointers), and it contains only weak pointers
      to other objects.
      When the weakly-referenced object goes out of scope and gets
      destroyed, not only does the weak pointer, in the weak container,
      becomes undefined, it gets removed from the container, automatically.
    </para>

    <para>
      <ulink url="&link-typedef-x-weaklist;"><classname>&ns;::weaklist</classname></ulink>
      is a template alias for <link linkend="ref">a reference</link> to
      a container with
      <classname>std::list</classname>-like properties.
      <ulink url="&link-typedef-x-weaklistptr;"><classname>&ns;::weaklistptr</classname></ulink>
      is the corresponding &ptr; template alias.
      The <classname>&ns;::weaklist</classname> accepts
      weak pointers:
    </para>

    <blockquote>
      <informalexample>
	<programlisting>
#include &lt;&ns;/weaklist.H&gt;

class widgetObj;

typedef &ns;:ref&lt;widgetObj&gt; widget;

typedef &ns;::weaklist&lt;widgetObj&gt; weakwidgetlist;

weakwidgetlist currentWidgets(weakwidgetlist::create());

// ...

widget p=widget::create();

currentWidgets-&gt;push_back(p);</programlisting>
      </informalexample>
    </blockquote>

    <para>
      The template parameter is a <link linkend="refobj">reference-counted
	object</link>.
      <classname>&ns;::weaklist</classname> and
      <classname>&ns;::weaklistptr</classname> refer to a
      <classname>std::list</classname>-like objects whose
      <methodname>push_front</methodname>() and
      <methodname>push_back</methodname>() methods take a regular,
      strong reference, but place a
      <link linkend="weakptr">weak pointer</link> into the weak list.
      <methodname>push_front</methodname>() and
      <methodname>push_back</methodname>() do not retain the strong reference
      they receive as a parameter, they retain only a weak pointer.
    </para>

    <para>
      There is no <methodname>erase</methodname>() method in the container.
      When the weakly-referenced object goes out of scope and gets destroyed,
      the weak pointer also gets removed from the container.
    </para>

    <blockquote>
      <informalexample>
	<programlisting>
for (weakwidgetlist::base::iterator b=currentWidgets->begin(),
     e=currentWidgets->end(); b != e; ++b)
{
    widgetptr p=b->getptr();

    if (!p.null())
    {
       // ...
</programlisting>
      </informalexample>
    </blockquote>

    <para>
      Weak list containers offer
      <methodname>begin()</methodname>,
      <methodname>end()</methodname>,
      <methodname>empty()</methodname>,
      <methodname>size()</methodname>,
      <methodname>push_back()</methodname>, and
      <methodname>push_front()</methodname>.
      Iteration over a weak list container iterates over
      <link linkend="weakptr">weak pointers</link>. Use
      <methodname>getptr</methodname>() to recover a strong
      reference.
    </para>

    <note id="weakcontainergetptrnull">
      <para>
	It's possible that <methodname>getptr</methodname>() might return
	a null &ptr;, even though the container automatically removes
	weak pointers upon destruction of the referenced object.
	When the last reference to the weakly-referenced object goes out of
	scope and it gets destroyed, the weak pointer to the object normally
	gets removed from the container automatically.
      </para>

      <para>
	However, this is not possible when there are iterators still in scope.
	They are currently iterating over the weak container, and the
	container can't be modified as long as they remain in scope; so
	the weak pointers do not get immediately removed, and
	<methodname>getptr</methodname>() subsequently returns
	a null &ptr;.
      </para>

      <para>
	The weak pointer to the destroyed object gets eventually removed
	from the weak container, after the last
	weak container iterator goes out of scope and gets destroyed.
	Until that happens, it's possible for weak container iterators to
	iterate over a weak null pointer.
      </para>
    </note>

    <para>
      For this reason, iterators over a weak list, or a weak map,
      should be short lived, and not stashed away someplace. Where possible,
      use a <link linkend="createrange">range iterator</link>.
    </para>

    <para>
      <ulink url="&link-typedef-x-weakmap;"><classname>&ns;::weakmap</classname></ulink>,
      <ulink url="&link-typedef-x-weakmultimap;"><classname>&ns;::weakmultimap</classname></ulink>,
      <ulink url="&link-typedef-x-weakunordered-map;"><classname>&ns;::weakunordered_map</classname></ulink>,
      <ulink url="&link-typedef-x-weakunordered-multimap;"><classname>&ns;::weakunordered_multimap</classname></ulink>,
      define analogous containers with map-like properties:
    </para>

    <blockquote>
      <informalexample>
	<programlisting>
#include &lt;&ns;/weakmap.H&gt;

// Or multimap.H

class widgetObj;

typedef &ns;:ptr&lt;widgetObj&gt; widgetptr;

typedef &ns;::weakmap&lt;std::string, widgetObj&gt; weakwidgetmap;

weakwidgetmap currentWidgets(weakwidgetmap::create());

// ...

widgetptr p=widgetptr::create();

currentWidgets-&gt;insert(std::make_pair("left", p));

// ...

weakwidgetmap::base::iterator iter=currentWidgets-&gt;find("left");

if (iter != currentWidgets-&gt;end())
{
    widgetptr p=iter-&gt;second.getptr();

    if (!p.null())
    {
// ...</programlisting>
      </informalexample>
    </blockquote>

    <para>
      Like a weak list container's, the weak maps do not implement
      <methodname>erase</methodname>(); when the weakly-referenced object goes out
      of scope and gets destroyed, its weak pointers gets removed
      automatically, if no iterators exist at the time; or after the last
      iterator goes out of scope and gets destroyed.
      It follows that iterators over the maps' contents should have a brief
      existence, to avoid the containers growing with undefined weak
      pointers.
    </para>

    <para>
      Not surprisingly, weak map iterators iterate over
      <classname>std::pair</classname>s containing the key, and its
      corresponding weak pointer.
      Weak map containers implement the following
      <classname>std::map</classname>/<classname>std::multimap</classname>
      methods:
      <methodname>begin()</methodname>,
      <methodname>end()</methodname>,
      <methodname>empty()</methodname>,
      <methodname>size()</methodname>,
      <methodname>find()</methodname>,
      <methodname>count()</methodname>,
      <methodname>lower_bound()</methodname>,
      <methodname>upper_bound()</methodname>, and
      <methodname>equal_range()</methodname> (meaningful only for
      <classname>&ns;::weakmultimap</classname>s).
    </para>

    <para>
      <methodname>insert()</methodname> adds a weak pointer to the map.
      An alternative version of <methodname>insert()</methodname>
      exists, that takes the key
      and the pointer separately, without the need for an intermediate
      <classname>std::pair</classname>:
    </para>

    <blockquote>
      <informalexample>
	<programlisting>
currentWidgets-&gt;insert("left", p);</programlisting>
      </informalexample>
    </blockquote>

    <para>
      The weak map container also offers <methodname>operator[]</methodname>,
      as syntactical sugar, but since the container is a reference-counted
      object that must be dereferenced by a <methodname>*</methodname>, this may
      not be very useful.
    </para>

    <blockquote>
      <informalexample>
	<programlisting>
#include &lt;&ns;/weakmultimap.H&gt;

class widgetObj;

typedef &ns;:ptr&lt;widgetObj&gt; widgetptr;

typedef &ns;::weakmultimap&lt;std::string, widgetObj&gt; weakwidgetmap;

weakwidgetmap currentWidgets(weakwidgetmap::create());

// ...

&ns;::ref&lt;widgetObj&gt;
    w=currentWidgets-&gt;find_or_create("left", []
                                             {
                                                 return ref&lt;widgerObj&gt;::create();
                                             });</programlisting>
      </informalexample>
    </blockquote>

    <para>
      Recall that although weak pointers get automatically removed from
      weak containers when the referenced object goes out of scope and
      gets destroyed, there are edge conditions when iterating over the
      weak container iterates over a weak pointer
      <link linkend="weakcontainergetptrnull">whose
	<methodname>getptr</methodname>() can return a
	<literal>nullptr</literal></link>.
      For that reason, sometimes a weak multimap is a better choice instead of a
      weak map for a key/value lookup mapping.
      With a weak map, it's possible that the weak pointer continues to exist
      in the map, for the given key, making it impossible to store a
      weakly-referenced value for the given key.
    </para>

    <para>
      With a weak multimap, or a weak unordered multimap,
      if a key's value is a null weak pointer, a new
      value for the same key can still be inserted into this map.
      <methodname>find_or_create</methodname>() is a convenient atomic
      method that does the following:
    </para>

    <itemizedlist>
      <listitem>
	<para>
	  The first parameter to <methodname>find_or_create</methodname>() is
	  a map key.
	</para>

	<para>
	  <methodname>find_or_create</methodname>() checks
	  if the map contains any key with the given value, whose
	  weak pointer returns a non-<literal>nullptr</literal> reference, if
	  so <methodname>find_or_create</methodname>() returns it.
	</para>
      </listitem>
      <listitem>
	<para>
	  The second parameter to <methodname>find_or_create</methodname>() is
	  a lambda. The lambda must return an &ref; to the map's
	  weakly-referenced object.
	</para>

	<para>
	  If the map does not contain any value for the given key, or if all
	  of them have weak pointers
	  that return a <literal>nullptr</literal>:
	  <methodname>find_or_create</methodname>() calls the lambda, inserts
	  the key, and the value returned from the lambda, then returns the
	  same value.
	</para>

	<note>
	  <para>
	    <methodname>find_or_create</methodname>() is less useful with a
	    <classname>&ns;::weakmap</classname> or a
	    <classname>&ns;::weakunordered_map</classname>,
	    which are based on a
	    <classname>std::map</classname>/<classname>std::unordered_map</classname>,
	    that allow only one value per
	    key. As metioned before, weak pointers to destroyed objects
	    cannot get removed from the weak container as long as
	    <link linkend="weakcontainergetptrnull">any iterators
	    to the weak container are still in scope</link>.
	    <methodname>find_or_create</methodname>() might find an existing
	    value for the key in the <classname>&ns;::weakmap</classname>,
	    but unable to remove it.
	  </para>

	  <para>
	    <methodname>find_or_create</methodname>() returns a &ptr;, and
	    returns a null one, in that situation; but only after
	    the lambda gets called and returns its &ref;.
	    Immediately afterwards,
	    <methodname>find_or_create</methodname>() fails to insert the
	    new &ref;, which then goes out of scope and gets destroyed, and a
	    null &ptr; gets returned.
	  </para>

	  <para>
	    <classname>&ns;::weakmultimap</classname>'s
	    and <classname>&ns;::weakunordered_multimap</classname>'s
	    <methodname>find_or_create</methodname>()
	    has no problems inserting
	    a new value for the same key, of course, and won't have this
	    problem; so its <methodname>find_or_create</methodname>()
	    always returns a &ref;
	  </para>
	</note>
      </listitem>
    </itemizedlist>

    <section id="mcguffincontainers">
      <title>Mcguffin containers</title>

      <para>
	Once something gets added to a
	<ulink url="&link-typedef-x-weaklist;"><classname>&ns;::weaklist</classname></ulink>,
	<ulink url="&link-typedef-x-weakmap;"><classname>&ns;::weakmap</classname></ulink>,
	<ulink url="&link-typedef-x-weakmultimap;"><classname>&ns;::weakmultimap</classname></ulink>,
	<ulink url="&link-typedef-x-weakunordered-map;"><classname>&ns;::weakunordered_map</classname></ulink>, or
	<ulink url="&link-typedef-x-weakunordered-multimap;"><classname>&ns;::weakunordered_multimap</classname></ulink>,
	it remains in the weak container until the referenced object goes out
	of scope and gets destroyed.
	Alternatively,
	<ulink url="&link-typedef-x-mcguffinlist;"><classname>&ns;::mcguffinlist</classname></ulink>,
	<ulink url="&link-typedef-x-mcguffinmap;"><classname>&ns;::mcguffinmap</classname></ulink>,
	<ulink url="&link-typedef-x-mcguffinmultimap;"><classname>&ns;::mcguffinmultimap</classname></ulink>
	<ulink url="&link-typedef-x-mcguffinunordered-map;"><classname>&ns;::mcguffinunordered_map</classname></ulink>, or
	<ulink url="&link-typedef-x-mcguffinunordered-multimap;"><classname>&ns;::mcguffinunordered_multimap</classname></ulink>
	are based on their weak counterparts, but take
	 a <link linkend="ondestroy">mcguffin</link>-based approach that
	allows removal of referenced objects that still exist,
	from their container.
      </para>

      <blockquote>
	<informalexample>
	  <programlisting>
#include &lt;&ns;/mcguffinlist.H&gt;
#include &lt;&ns;/mcguffinmap.H&gt;
#include &lt;&ns;/mcguffinmultimap.H&gt;

class widgetObj;

typedef &ns;::ref&lt;widgetObj&gt; widget;
typedef &ns;::ptr&lt;widgetObj&gt; widgetptr;

&ns;::mcguffinlist&lt;widget&gt; l=&ns;::mcguffinlist&lt;widget&gt;::create();
&ns;::mcguffinmap&lt;int, widget&gt; m=&ns;::mcguffinmap&lt;int, widget&gt;::create();
&ns;::mcguffinmultimap&lt;int, widget&gt; mm=&ns;::mcguffinmultimap&lt;int, widget&gt;::create();

&ns;::ref&lt;&ns;::obj&gt; mcguffin=l-&gt;push_back(widget::create());

&ns;::ptr&lt;&ns;::obj&gt; mcguffin=m-&gt;insert(0, widget::create());

std::pair&lt;&ns;::ptr&lt;&ns;::obj&gt;, widgeptrt&gt; ref=m-&gt;find_or_create(0, [] { return widget::create(); });

for (&ns;::mcguffinlist&lt;widget&gt;::base::iterator b=l->begin(), e=l->end(); b != e; ++b)
{
    widgetptr p=b->getptr();
    &ns;::ptr&lt;&ns;::obj&gt; mcguffin=b->mcguffin();
    b->erase();
}

for (&ns;::mcguffinmultimap&lt;widget&gt;::base::iterator b=mm->begin(), e=mm->end(); b != e; ++b)
{
    widgetptr p=b->second.getptr();
    &ns;::ptr&lt;&ns;::obj&gt; mcguffin=b->second.mcguffin();
    b->second.erase();
}</programlisting>
	</informalexample>
      </blockquote>
    </section>

    <para>
      These mcguffin containers work the same as their weak counterparts,
      and implement the same methods; but with the following differences.
    </para>

    <itemizedlist>
      <listitem>
	<para>
	  The first parameter to the
	  <ulink url="&link-typedef-x-mcguffinlist;"><classname>&ns;::mcguffinlist</classname></ulink>,
	  and the second parameter to the
	  <ulink url="&link-typedef-x-mcguffinmap;"><classname>&ns;::mcguffinmap</classname></ulink>,
	  <ulink url="&link-typedef-x-mcguffinmultimap;"><classname>&ns;::mcguffinmultimap</classname></ulink>
	  <ulink url="&link-typedef-x-mcguffinunordered-map;"><classname>&ns;::mcguffinunordered_map</classname></ulink> or
	  <ulink url="&link-typedef-x-mcguffinunordered-multimap;"><classname>&ns;::mcguffinunordered_multimap</classname></ulink>
	  templates must be a &ref;.
	</para>
      </listitem>

      <listitem>
	<para>
	  <ulink url="&link-typedef-x-mcguffinlist;"><classname>&ns;::mcguffinlist</classname></ulink>'s
	  <methodname>push_front</methodname>() and
	  <methodname>push_back</methodname>() return an opaque
	  <classname>&ns;::ref&lt;&ns;::obj&gt;</classname>
	  <link linkend="ondestroy">mcguffin</link>.
	</para>
      </listitem>

      <listitem>
	<para>
	  <ulink url="&link-typedef-x-mcguffinmap;"><classname>&ns;::mcguffinmap</classname></ulink>'s
	  and
	  <ulink url="&link-typedef-x-mcguffinunordered-map;"><classname>&ns;::mcguffinunordered_map</classname></ulink>'s
	  <methodname>insert</methodname>()
	  returns an opaque
	  <classname>&ns;::ptr&lt;&ns;::obj&gt;</classname>
	  mcguffin.
	  A null &ptr; gets returned if the value cannot be inserted into
	  the map because the key already exists.
	</para>
      </listitem>

      <listitem>
	<para>
	  <ulink url="&link-typedef-x-mcguffinmultimap;"><classname>&ns;::mcguffinmultimap</classname></ulink>
	  and
	  <ulink url="&link-typedef-x-mcguffinunordered-multimap;"><classname>&ns;::mcguffinunordered-multimap</classname></ulink>
	  <methodname>insert</methodname>()
	  returns an opaque
	  <classname>&ns;::ref&lt;&ns;::obj&gt;</classname>
	  mcguffin.
	</para>
      </listitem>

      <listitem>
	<para>
	  <ulink url="&link-typedef-x-mcguffinmap;"><classname>&ns;::mcguffinmap</classname></ulink>'s,
	  <ulink url="&link-typedef-x-mcguffinmultimap;"><classname>&ns;::mcguffinmultimap</classname></ulink>,
	  <ulink url="&link-typedef-x-mcguffinunordered-map;"><classname>&ns;::mcguffinunordered_map</classname></ulink>'s
	  and
	  <ulink url="&link-typedef-x-mcguffinunordered-multimap;"><classname>&ns;::mcguffinunordered_multimap</classname></ulink>
	  <methodname>find_or_create</methodname>() returns
	  <classname>std::pair</classname> with both the mcguffin and the
	  value.
	  <ulink url="&link-typedef-x-mcguffinmap;"><classname>&ns;::mcguffinmap</classname></ulink>'s and
	  <ulink url="&link-typedef-x-mcguffinunordered-map;"><classname>&ns;::mcguffinunordered_map</classname></ulink>'s
	  <classname>std::pair</classname> contains &ptr;s,
	  <ulink url="&link-typedef-x-mcguffinmultimap;"><classname>&ns;::mcguffinmultimap</classname></ulink>'s and
	  <ulink url="&link-typedef-x-mcguffinunordered-multimap;"><classname>&ns;::mcguffinunordered_multimap</classname></ulink>
	  <classname>std::pair</classname> contains &ref;s.

	  <ulink url="&link-typedef-x-mcguffinmap;"><classname>&ns;::mcguffinmap</classname></ulink>'s and
	  <ulink url="&link-typedef-x-mcguffinunordered-map;"><classname>&ns;::mcguffinunordered_map</classname></ulink>'s
	  <classname>std::pair</classname> contains null &ptr;s if it couldn't
	  create a new value for the key.
	  In all other situations, either the existing map's value and its
	  mcguffin, or the new value returned by the lambda and its mcguffin,
	  get returned.
	</para>
      </listitem>
    </itemizedlist>

    <para>
      The mcguffin owns a strong reference on the inserted object.
      The iterators' value's <methodname>getptr</methodname>() returns the
      supposedly inserted object, just like the weak containers;
      however the underlying weak containers actually
      weakly-reference the corresponding mcguffins, so when the inserted
      object's mcguffin goes out of scope and gets destroyed, the inserted
      object gets removed from the container, even if other strong references
      to the inserted object are still in some scope, somewhere.
    </para>

    <para>
      The iterators' values also implement two additional methods:
    </para>

    <variablelist>
      <varlistentry>
	<term><literal>&ns;::ptr&lt;&ns;::obj&gt; mcguffin();</literal></term>
	<listitem>
	  <para>
	    Returns the mcguffin for the inserted object. A null
	    &ptr; gets returned if the object is no longer in the container.
	  </para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>void erase();</literal></term>
	<listitem>
	  <para>
	    Removes the value from the container, even if its mcguffin is
	    still in scope. Afterwards, the same iterator's value's
	    <methodname>getptr</methodname>() will always return a null
	    &ptr;, and the container entry gets removed when the iterator
	    goes out of scope.
	  </para>
	</listitem>
      </varlistentry>
    </variablelist>

  </section>

  <section id="circularrefs">
    <title>Circular strong references</title>

    <para>
      &ref;s and &ptr;s generally take the chore out of keeping track of
      heap-allocated objects, and destroying them when they're no longer needed.
      When the last reference to the object goes away, that's it. For this to
      work, it's important not to create circular references.
      The simplest circular reference is an &reforptr;
      in one object pointing to a second object, and an &reforptr;
      in the second object pointing to the first one. This is true for a
      circular reference of any size or structure, a sequence of any lengths
      of &ref;'s; and &ptr;s eventually leading back to the starting point.
      A circular reference prevents the
      objects from getting destroyed, when no other references to the objects
      in a circular reference remain.
    </para>

    <para>
      <link linkend="weakptr">Weak pointers</link> do not count, and
      won't create circular references, but there has to be a strong reference
      to an object somewhere, for it to exist. &app;'s documentation
      often specifies
      when a class or an object instance holds a strong reference to another
      object, and under what circumstances. This should be considered when
      designing a class hierarchy, and avoiding creation of circular references
      and memory leaks.
    </para>

    <para>
      The internal usage of &ref;'s and &ptr;'s is very widespread, and their
      existence gets explicitly noted, in this documentation, only when it is
      counterintuitive, or not obvious. For destructor callbacks and mcguffins:
    </para>

    <itemizedlist>
      <listitem>
	<para>
	  A mcguffin holds a strong reference on all callbacks that were
	  <link linkend="ondestroy"><methodname>addOnDestroy</methodname>()ed</link>.
	  Those strong references naturally go out of scope, and get destroyed,
	  as part of the mcguffin's destruction (and invocation of all of its
	  <methodname>addOnDestroy</methodname>()ed callbacks).
	</para>
      </listitem>

      <listitem>
	<para>
	  An
	  <link linkend="ondestroyrevocable"><classname>&ns;::ondestroy</classname></link>
	  indirectly holds a strong reference to the mcguffin's destructor
	  callback. <classname>&ns;::ondestroy</classname> does not actually
	  hold a strong reference of its own.
	  What happens is that <classname>&ns;::ondestroy</classname>'s
	  <methodname>cancel</methodname>() (whether invoked explicitly or
	  implicitly) releases the mcguffin's strong reference on its callback,
	  if it's not yet invoked. If it was already invoked, as part of the
	  mcguffin's destruction, <classname>&ns;::ondestroy</classname> has
	  no further impact.
	</para>
      </listitem>

      <listitem>
	<para>
	  <link linkend="onanydestroy"><methodname>onAnyDestroyed</methodname></link>()
	  creates a strong reference from every mcguffin, defined by the
	  input sequence, to <methodname>onAnyDestroyed</methodname>()'d
	  destructor callback. Those strong references go out of scope when
	  one of those mcguffins goes out of scope, gets destroyed, and results
	  in the contracted-for invocation of
	  <methodname>destroyed</methodname>().
	</para>
      </listitem>
    </itemizedlist>
  </section>
</chapter>

<!--
Local Variables:
mode: sgml
sgml-parent-document: ("book.xml" "book" "chapter")
End:
-->
