<!--

Copyright 2012 Double Precision, Inc.
See COPYING for distribution information.

-->

<chapter id="mimeparser">
  <title>Parsing &MIME; documents</title>

  <para>
    The templates and classes describe in this chapter implement an output
    iterator-based approach to parsing &MIME; documents. A &MIME; parser
    gets constructed by instantiating a sequence of template classes.
    Each one of them is an output iterator over a sequence, a stream
    of tokens, that modifies the stream and passes the modified stream
    to the next output iterator.
  </para>

  <section id="mimeparsernewlineiter">
    <title>Delimiting &MIME; newline sequences</title>

    <para>
      The initial output iterator,
      <ulink url="&link-x--mime--newline-iter;"><classname>&ns;::mime::newline_iter</classname></ulink>,
      instantiates an output iterator over <classname>char</classname> values.
      Its template parameter is an output iterator class which iterates over
      <classname>int</classname> values.
      <classname>&ns;::mime::newline_iter</classname> takes the
      <classname>char</classname> sequence it iterates over, and promotes each
      character to an <classname>int</classname> between 0 and 255.
      Additionally,
      <classname>&ns;::mime::newline_iter</classname>
      inserts an <literal>&ns;::mime::newline_start</literal> into the output
      sequence before each newline sequence, and
      <literal>&ns;::mime::newline_end</literal> after the newline sequence.
    </para>

    <note>
      <para>
	All other output iterators described in this chapter iterate over
	an <classname>int</classname> value sequence, which consists of
	the <classname>char</classname> values, from the original output
	sequence that comprises the MIME document, and additional values
	inserted by these output iterators.
      </para>

      <para>
	Its important to note that
	the original <classname>char</classname> output sequence does not
	get modified, but gets supplemented by <classname>int</classname>
	values that the output iterators insert into the output sequence,
	like <literal>&ns;::mime::newline_start</literal> and
	<literal>&ns;::mime::newline_end</literal>, which appear before and
	after the <literal>LF</literal>
	(<link linkend="mimenewlineitercrlf">or
	  the <literal>CRLF</literal></link>)
	value.
	The <literal>LF</literal> (or the <literal>CRLF</literal> values)
	remain in the output sequence where they were, but get bracketed by
	<literal>&ns;::mime::newline_start</literal> and
	<literal>&ns;::mime::newline_end</literal>.
      </para>
    </note>

    <blockquote>
      <title><ulink url="examples">examples/mime/newlineparser.C</ulink></title>
      <informalexample>
	<programlisting><xi:include href="../examples/mime/newlineparser.C" parse="text" xmlns:xi="http://www.w3.org/2001/XInclude" /></programlisting>
      </informalexample>
    </blockquote>

    <para>
      Instantiating a <classname>&ns;::mime::newline_iter</classname> results
      in an output iterator, but <classname>&ns;::mime::newline_iter</classname>
      gets instantiated by <function>create</function>() like a
      <link linkend="create">reference-counted object</link>
      (because, internally, it is).
      The template parameter is an output iterator class over
      <classname>int</classname>s, and the constructor
      takes an instance of the template parameter class.
    </para>

    <para>
      This example copies <classname>char</classname>s from
      <literal>std::cin</literal> into the instantiated
      <classname>&ns;::mime::newline_iter</classname>,
      which outputs to a
      <classname>std::back_insert_iterator&lt;std::vector&lt;int&gt;&gt;</classname>.
    </para>

    <para id="mimegeteof">
      No formal means exist to notify an output iterator of an end to the
      output sequence, other than its destruction, so the &MIME; parsing
      iterators use this convention. The output iterator's
      <methodname>get</methodname>() method returns a reference to the
      underlying reference-counted method, with an
      <methodname>eof</methodname>() that must be invoked in order to signal
      the end of the output sequence.
      All &MIME; parsing templates and classes require that
      <classname>&ns;::mime::newline_iter</classname>'s
      <methodname>eof</methodname>() must get invoked.
    </para>

    <para>
      In addition to <methodname>eof</methodname>(), the
      <varname>iter</varname> class member gives the current value of the
      output iterator that
      <classname>&ns;::mime::newline_iter</classname>'s constructor received,
      via <methodname>create</methodname>().
      Sample output from the above <filename>newlineparser.C</filename>
      example:
    </para>

    <computeroutput>
      <literallayout><![CDATA[
$ cat newlineparser.txt
Subject: test

test
$ ./newlineparser <newlineparser.txt
Subject: test<256>
<257><256>
<257>test<256>
<257><-1>]]>
      </literallayout>
    </computeroutput>

    <para>
      <classname>&ns;::mime::newline_iter</classname> promotes the
      <classname>char</classname> sequence it iterates over to
      <classname>int</classname> between 0 and 255.
      <methodname>&ns;::mime::nontoken</methodname>() returns
      <literal>true</literal> if the given value is in this range, and
      <literal>false</literal> for additional tokens. As the sample output
      shows, <literal>256</literal> and <literal>257</literal>
      (corresponding to
      <literal>&ns;::mime::newline_start</literal> and
      <literal>&ns;::mime::newline_end</literal>) wrap each newline character.
      <literal>-1</literal> is <literal>&ns;::mime::eof</literal> that gets
      inserted by 
      <classname>&ns;::mime::newline_iter</classname>'s
      <methodname>eof</methodname>().
    </para>

    <para>
      One important characteristic of
      <classname>&ns;::mime::newline_iter</classname> is that when the
      output sequence does not end with a newline,
      <classname>&ns;::mime::newline_iter</classname> inserts
      <literal>&ns;::mime::newline_start</literal> immediately followed by
      <literal>&ns;::mime::newline_end</literal>, without a newline in between
      (this gets triggered by <methodname>eof</methodname>()).
      In all cases
      <classname>&ns;::mime::newline_iter</classname> does not modify the
      character part of the output sequence that gets forwarded to its
      output iterator, but the output sequence always ends with a newline
      sequence:
    </para>

    <computeroutput>
      <literallayout><![CDATA[
$ cat newlineparser.txt
Subject: test

test
$ ./newlineparser <newlineparser.txt
Subject: test<256>
<257><256>
<257>test<256><257><-1>]]>
      </literallayout>
    </computeroutput>

    <para>
      This is same as the previous example, except that the original
      &MIME;-formatted message did not end with a newline.
      <classname>&ns;::mime::newline_iter</classname> adds
      <literal>&ns;::mime::newline_start</literal> (256) immediately followed by
      <literal>&ns;::mime::newline_end</literal> (257), before the trailing
      <literal>&ns;::mime::eof</literal>.
    </para>

    <section id="mimenewlineitercrlf">
      <title>Parsing &MIME; documents that use <literal>CRLF</literal> newline sequences</title>

      <blockquote>
	<informalexample>
	  <programlisting>
&ns;::mime::newline_iter&lt;ins_iter_t&gt;::create(ins_iter_t(seq), true);</programlisting>
	</informalexample>
      </blockquote>

      <para>
	Setting the second optional parameter to 
	<classname>&ns;::mime::newline_iter</classname>'s
	<function>create</function>() to <literal>true</literal> instantiates
	the output iterator that recognizes <literal>CRLF</literal> sequence as
	the newline sequence instead of <literal>LF</literal>.
      </para>
      <para>
	<classname>&ns;::mime::newline_iter</classname> inserts
	<literal>&ns;::mime::newline_start</literal> and
	<literal>&ns;::mime::newline_end</literal> before and after
	each <literal>CRLF</literal> sequence. <literal>CR</literal> and
	<literal>LF</literal> by themselves are left alone.
      </para>
    </section>

    <section id="mimenewlineitersummary">
      <title>Summary</title>

      <para>
	<classname>&ns;::mime::newline_iter</classname> iterates over a
	<classname>char</classname>-valued output sequence that contains
	a &MIME; document. Its template parameter parameter is an
	output iterator class that iterates over
	<classname>int</classname> values, and <function>create</function>()
	takes an instance of the template class.
      </para>

      <para>
	The iterator passed to <function>create</function>() iterates over
	an <classname>int</classname> values that consists of the
	<classname>char</classname> values that
	<classname>&ns;::mime::newline_iter</classname> iterates over.
	Additionally, each recognized newline sequence gets preceded by a
	<literal>&ns;::mime::newline_start</literal> and followed by
	<literal>&ns;::mime::newline_end</literal>.
	This includes the implied newline at the end of the output sequence
	that does not end with an explicit newline sequence.
	Invoking <methodname>eof</methodname>() on
	<classname>&ns;::mime::newline_iter</classname>'s output iterator
	object insert the
	<literal>&ns;::mime::eof</literal> into the output sequence.
      </para>
    </section>
  </section>

  <section id="mimeparserbodystartiter">
    <title>Detecting start of a &MIME; document's body</title>

    <para>
      Most of the time,
      <link linkend="mimeparsernewlineiter"><classname>&ns;::mime::newline_iter</classname></link>'s
      output iterator is a
      <ulink url="&link-x--mime--bodystart-iter;"><classname>&ns;::mime::bodystart_iter</classname></ulink>
      which is an output iterator over a sequence of
      <classname>int</classname>s.
      <classname>&ns;::mime::bodystart_iter</classname>'s template parameter
      is an output iterator class. It iterates over the same sequence as
      <classname>&ns;::mime::bodystart_iter</classname> iterates over,
      unchanged, except that the first time that
      <classname>&ns;::mime::bodystart_iter</classname> iterates over two
      <literal>&ns;::mime::newline_start</literal>/<literal>&ns;::mime::newline_end</literal>
      tuples in a row,
      <classname>&ns;::mime::bodystart_iter</classname> adds an
      <literal>&ns;::mime::body_start</literal> value to the output sequence,
      after the second tuple. This marks the start of a &MIME; document's
      body, following the first empty line:
    </para>

    <blockquote>
      <title><ulink url="examples">examples/mime/bodystart.C</ulink></title>
      <informalexample>
	<programlisting><xi:include href="../examples/mime/bodystart.C" parse="text" xmlns:xi="http://www.w3.org/2001/XInclude" /></programlisting>
      </informalexample>
    </blockquote>

    <para>
      Instantiating a <classname>&ns;::mime::bodystart_iter</classname> results
      in an output iterator, but <classname>&ns;::mime::bodystart_iter</classname>
      gets instantiated by <function>create</function>() like a
      <link linkend="create">reference-counted object</link>
      (because, internally, it is).
      Like
      <link linkend="mimeparsernewlineiter"><classname>&ns;::mime::newline_iter</classname></link>,
      the output iterator's
      <methodname>get</methodname>() method returns a reference to the
      underlying reference-counted method, with an
      <varname>iter</varname> class member giving the current value of the
      underlying output iterator.
      In this example, <classname>std::copy</classname> returns the new value
      of the output iterator, <classname>newline_iter_t</classname>, a.k.a.
      <classname>&ns;::mime::newline_iter&lt;bodystart_iter_t&gt;</classname>.
      Its <literal>get()-&gt;iter</literal> returns its underlying
      output iterator, <classname>bodystart_iter_t</classname>,
      a.k.a.
      <classname>&ns;::mime::bodystart_iter&lt;ins_iter_t&gt;</classname>,
      and its own <literal>get()-&gt;iter</literal> returns the underlying
      <classname>ins_iter_t</classname>. Sample output from this example:
    </para>

    <computeroutput>
      <literallayout><![CDATA[
$ cat bodystart.txt
Subject: test

test
$ ./bodystart <bodystart.txt
Subject: test<256>
<257><256>
<257><258>test<256>
<257><-1>]]>
      </literallayout>
    </computeroutput>

    <para>
      <literal>&ns;::mime::body_start</literal>, or <literal>258</literal>
      gets inserted into the output sequence after the second consecutive
      newline sequence, marking the start the &MIME; section's body.
      If two consecutive newline sequences do not appear in the sequence,
      a <literal>&ns;::mime::body_start</literal>
      still gets inserted into the
      output sequence before the <literal>&ns;::mime::eof</literal>:
    </para>

    <computeroutput>
      <literallayout><![CDATA[
$ cat bodystart.txt
Subject: test
$ ./bodystart <bodystart.txt
Subject: test<256>
<257><258><-1>]]></literallayout>
    </computeroutput>
  </section>

  <section id="mimeparserheaderiter">
    <title>Header parser iterator</title>

    <para>
      The
      <ulink url="&link-x--mime--header-iter;"><classname>&ns;::mime::header_iter</classname></ulink>
      template instantiates an output iterator that takes the output sequence
      from <link linkend="mimeparserbodystartiter"><classname>&ns;::mime::bodystart_iter</classname></link>.
      The template parameter is another output iterator class, over an
      <classname>int</classname> output sequence.
      Instantiated by <function>create</function>(), the constructor takes
      an instance of the output iterator class, which ends up iterating over
      the output sequence that
      <classname>&ns;::mime::header_iter</classname>
      received, and
      <classname>&ns;::mime::header_iter</classname>
      adds additional values into the output sequence:
    </para>

    <itemizedlist>
      <listitem>
	<para>
	  The name of each header gets preceded by an
	  <literal>&ns;::mime::header_name_start</literal> and followed by an
	  <literal>&ns;::mime::header_name_end</literal>.
	</para>
      </listitem>

      <listitem>
	<para>
	  The contents of each header gets preceded by an
	  <literal>&ns;::mime::header_contents_start</literal> and followed by
	  an
	  <literal>&ns;::mime::header_contents_end</literal>.

	  <literal>&ns;::mime::header_name_start</literal> and 
	  <literal>&ns;::mime::header_name_end</literal> are always followed by
	  <literal>&ns;::mime::header_contents_start</literal> and
	  <literal>&ns;::mime::header_contents_end</literal>, but
	  <literal>&ns;::mime::header_contents_start</literal> does not
	  immediately follow a
	  <literal>&ns;::mime::header_name_end</literal>.
	</para>

	<para>
	  The portion of the output sequence delimited by
	  <literal>&ns;::mime::header_contents_start</literal> and
	  <literal>&ns;::mime::header_contents_end</literal> excludes the
	  colon and whitespace that separates the header name from its
	  contents.
	  <classname>&ns;::mime::header_iter</classname> does not
	  remove values from the output sequence it receives, it only adds
	  these additional values.
	</para>
      </listitem>

      <listitem>
	<para>
	  For multiline header contents, the sequence delimited by an
	  <literal>&ns;::mime::header_contents_start</literal> and an
	  <literal>&ns;::mime::header_contents_end</literal> has
	  additional
	  <literal>&ns;::mime::header_fold_start</literal> and an
	  <literal>&ns;::mime::header_fold_end</literal> values that
	  delimiter the start and the end of the newline and leading spaces
	  on the continued header line. For the purpose of parsing the
	  headers contents, the output sequence between and including
	  <literal>&ns;::mime::header_fold_start</literal> and
	  <literal>&ns;::mime::header_fold_end</literal> is logically
	  equivalent to a single space character (as already mentioned,
	  <classname>&ns;::mime::header_iter</classname> does not
	  remove values from the output sequence it receives, it only adds
	  dditional values).
	</para>
      </listitem>

      <listitem>
	<para>
	  After
	  <classname>&ns;::mime::header_iter</classname> iterates over a
	  <literal>&ns;::mime::body_start</literal>,
	  the
	  <classname>&ns;::mime::header_iter</classname> passes it, and the
	  rest of the output sequence, with no further parsing or action.
	</para>
      </listitem>
    </itemizedlist>

    <blockquote>
      <title><ulink url="examples">examples/mime/headeriter.C</ulink></title>
      <informalexample>
	<programlisting><xi:include href="../examples/mime/headeriter.C" parse="text" xmlns:xi="http://www.w3.org/2001/XInclude" /></programlisting>
      </informalexample>
    </blockquote>

    <para>
      This example constructs a simple output iterator that receives
      the output sequence from a
      <classname>&ns;::mime::header_iter</classname>, collects all headers
      in a <classname>std::multimap</classname>, then shows them:
    </para>

    <computeroutput>
      <literallayout><![CDATA[
$ cat headeriter.txt
Mime-Version: 1.0
Subject: subject line
   folded header

test
$ ./headeriter <headeriter.txt
Header: Mime-Version, value: 1.0
Header: Subject, value: subject line folded header]]></literallayout>
    </computeroutput>

    <section id="mimeheadercollector">
      <title><classname>&ns;::mime::header_collector</classname></title>

      <para>
	<ulink url="&link-typedef-x--mime-header-collector;"><classname>&ns;::mime::header_collector</classname></ulink>
	implements a basic output iterator that turns the output sequence
	from a
	<classname>&ns;::mime::header_iter</classname> into calls to a lambda
	or a functor:
      </para>

      <blockquote>
	<title><ulink url="examples">examples/mime/headercollector.C</ulink></title>
	<informalexample>
	  <programlisting><xi:include href="../examples/mime/headercollector.C" parse="text" xmlns:xi="http://www.w3.org/2001/XInclude" /></programlisting>
	</informalexample>
      </blockquote>

      <para>
	This produces the same results as the previous example, with two
	small, but important, differences.
      </para>

      <itemizedlist>
	<listitem>
	  <para>
	    <function>&ns;::mime::header_collector::create</function>()
	    instantiates an output iterator over the sequence from
	    <classname>&ns;::mime::header_iter</classname>, and calls the
	    lambda or the functor that's passed to
	    <function>create()</function>. The functor/lambda
	    gets invoked with three parameters: the header name,
	    the header name converted to lowercase, and the contents of
	    the header.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    <classname>&ns;::mime::header_collector</classname>
	    does not store the headers from the &MIME; object it iterates over
	    into a container of any kind. The functor/lambda gets invoked
	    as soon as the entire header name
	    and contents get iterated over.
	  </para>
	</listitem>
      </itemizedlist>
    </section>
  </section>

  <section id="mimesectioninfo">
    <title>&MIME; section information</title>

    <blockquote>
      <informalexample>
	<programlisting>
#include &lt;&ns;/mime/sectioninfo.H&gt;

&ns;::mime::sectioninfo info=&ns;::mime::sectioninfo::create();</programlisting>
      </informalexample>
    </blockquote>

    <para>
      <ulink url="&link-typedef-x--mime-sectioninfo;"><classname>&ns;::mime::sectioninfo</classname></ulink>
      is a reference to a
      <link linkend="create">reference-counted object</link>
      that provides metadata about an entire &MIME; document, or one entity in
      a compound &MIME; document. It gets constructed and used by templates
      and functions described later in this chapter.
    </para>

    <para>
      The metadata in this object consists of:
    </para>

    <itemizedlist>
      <listitem>
	<para>
	  A <varname>children</varname> vector in a multipart &MIME; entity
	  gives <classname>&ns;::mime::sectioninfo</classname>s for each
	  subpart of a multipart entity.
	  A <literal>message/rfc822</literal> &MIME; entity has a vector
	  with one subpart, the &MIME; entity with the message.
	</para>

	<para>
	  A <link linkend="weakptr">weak pointer</link> to this &MIME; entity's
	  parent entity's <classname>&ns;::mime::sectioninfo</classname>.
	  The top level &MIME; entity's parent entity weak pointer is null.
	</para>
      </listitem>

      <listitem>
	<para>
	  The starting byte offset where this entity starts in the &MIME;
	  document. The
	  <classname>&ns;::mime::sectioninfo</classname> for the entire &MIME;
	  document has a starting offset of 0.
	</para>
      </listitem>

      <listitem>
	<para>
	  The number of octets in the header and the body portion of the
	  &MIME; entity, and the number of lines in each; also whether the
	  &MIME; entity does or does not have a trailing newline character.
	</para>
      </listitem>
    </itemizedlist>

    <para>
      See the <ulink url="&link-x--mime--sectioninfoObj;">class
	reference</ulink> for more information.
    </para>
  </section>

  <section id="mimeentityparser">
    <title>&MIME; entity parser</title>

    <para>
      After combining
      <link linkend="mimeparsernewlineiter"><classname>&ns;::mime::newline_iter</classname></link>,
      <link linkend="mimeparserbodystartiter"><classname>&ns;::mime::bodystart_iter</classname></link>,
      and
      <link linkend="mimeparserheaderiter"><classname>&ns;::mime::header_iter</classname></link>,
      use the following iterators to form a complete parser for a
      non-compound &MIME; section
      (with some assistance from a
      <link linkend="mimeheadercollector"><classname>&ns;::mime::header_collector</classname></link>):
    </para>

    <blockquote>
      <informalexample>
	<programlisting>
#include &lt;&ns;/mime/sectiondecoder.H&gt;

std::string content_transfer_encoding;

&ns;::mime::section_decoder decoder=
    &ns;::mime::section_decoder::create(content_transfer_encoding,
                                     std::ostreambuf_iterator&lt;char&gt;(std::cout));
	</programlisting>
      </informalexample>
    </blockquote>

    <para>
      The first parameter to
      <ulink url="&link-typedef-x--mime-section-decoder;"><classname>&ns;::mime::section_decoder</classname></ulink>'s
      <methodname>create</methodname>() is
      the value of the &MIME; <quote>Content-Transfer-Encoding</quote>
      header, like
      <quote>quoted-printable</quote>, or
      <quote>base64</quote> (all other values result in a non-transformative
      decoder).
      The second parameter is an output iterator over
      <classname>char</classname>s.
      <classname>&ns;::mime::section_decoder</classname>
      is an output iterator over
      <classname>int</classname>s from,
      at a minimum, an
      <classname>&ns;::mime::newline_iter</classname> that produces an
      output sequence of <classname>int</classname>s, demarcated by newlines,
      with a trailing <methodname>eof</methodname>().
    </para>

    <para>
      The output iterator instance received by
      <methodname>create</methodname>() gets iterated over
      <classname>char</classname> that were decoded using the specified
      transfer encoding.
    </para>

    <blockquote>
      <informalexample>
	<programlisting>
std::string content_transfer_encoding;
std::string charset;

&ns;::mime::section_decoder decoder=
    &ns;::mime::section_decoder::create(content_transfer_encoding,
                                     std::ostreambuf_iterator&lt;char&gt;(std::cout),
                                     charset, "UTF-8");
	</programlisting>
      </informalexample>
    </blockquote>

    <para>
      <methodname>create</methodname>() takes two optional parameters.
      For <literal>text</literal> &MIME; entities, the first optional
      parameter is the &MIME; entity's character set, from the
      <quote>Content-Type</quote> header. The second optional parameter
      is the application's character set. In addition to decoding the
      output sequence,
      <classname>&ns;::mime::section_decoder</classname>
      transcodes the <classname>char</classname>s from &MIME; entity's
      character set to the application character set.
    </para>

    <blockquote>
      <informalexample>
	<programlisting>
#include &lt;&ns;/mime/entityparser.H&gt;

&ns;::outputrefiterator&lt;int&gt; processor=&ns;::mime::make_entity_parser(
    &ns;::mime::header_collector::create(
        []
        (const std::string &amp;name,
	 const std::string &amp;name_lc,
	 const std::string &amp;value)
        {
            // ...
        }),
        []
        {
            return body_iterator();
        }, &ns;::mime::sectioninfo::create());</programlisting>
      </informalexample>
    </blockquote>

    <para>
      <ulink url="&link-function-x--mime-make-entity-parser;"><function>&ns;::mime::make_entity_parser</function></ulink>()
      combines
      <link linkend="mimeparserbodystartiter"><classname>&ns;::mime::bodystart_iter</classname></link>,
      <link linkend="mimeparserheaderiter"><classname>&ns;::mime::header_iter</classname></link>,
      and a few other odds and ends. It instantiates
      an output iterator that expects to be iterated over a single
      &MIME; entity.
      <function>&ns;::mime::make_entity_parser</function> returns
      a template class for an output iterator that's convertable to an
      <link linkend="outputrefiterator"><classname>&ns;::outputrefiterator&lt;int&gt;</classname></link>,
      and which iterates over an output sequence of <classname>int</classname>
      values produced by 
      <link linkend="mimeparsernewlineiter"><classname>&ns;::mime::newline_iter</classname></link>.
    </para>

    <para>
      <function>&ns;::mime::make_entity_parser</function>()
      takes three parameters, and returns an output iterator
      over <classname>int</classname>s.
      The first parameter becomes an output iterator that
      gets iterated over the header
      portion of the &MIME; entity.
      The iterator constructed by
      <link linkend="mimeheadercollector"><classname>&ns;::mime::header_collector</classname></link>
      is a popular choice for the header iterator, since
      <function>&ns;::mime::make_entity_parser</function>() already constructs
      an intermediate
      <link linkend="mimeparserheaderiter"><classname>&ns;::mime::header_iter</classname></link>
      anyway.
    </para>

    <para>
      When 
      <function>&ns;::mime::make_entity_parser</function>()'s iterator
      iterates over an <literal>&ns;::mime::body_start</literal>, the
      header iterator iterates over an <literal>&ns;::mime::eof</literal> value and
      the second parameter
      to
      <function>&ns;::mime::make_entity_parser</function>() gets invoked.
      The second parameter is a functor or a lambda that returns another
      output iterator over <classname>int</classname>s, which ends up iterating
      over the rest of the output sequence, after the
      <literal>&ns;::mime::body_start</literal>.
    </para>

    <para>
      <function>&ns;::mime::make_entity_parser</function>() encapsulaets
      the typical control flow of collecting the headers of a &MIME; entity,
      then figuring out how to parse the entity's body.
      The standard approach is to have the header iterator collect the
      &MIME; entity's headers, then have the functor/lambda figure out what
      to do with this entity, and return an output iterator that implements
      what's to be done.
    </para>

    <para>
      The third and the final parameter is a
      <link linkend="mimesectioninfo"><classname>&ns;::mime::sectioninfo</classname></link>.
      The output iterator returned by
      <function>&ns;::mime::make_entity_parser</function>() updates this
      object as it iterates over its output sequence.
    </para>

    <note>
      <para>
	<function>&ns;::mime::make_entity_parser</function>() returns an
	output iterator, and that's pretty much it. The show starts only after
	it actually iterates over something that resembles a &MIME; entity.
	This has a couple of implications.
      </para>

      <itemizedlist>
	<listitem>
	  <para>
	    What both functors or lambdas capture, and whether by reference
	    or by value, needs careful thought. The functors/lambdas do not
	    get invoked by
	    <function>&ns;::mime::make_entity_parser</function>(). They
	    get invoked, as appropriate, when the resulting output iterator
	    actually iterates over something. This usually means capturing by
	    value, preferrably a reference to a reference-counted object.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    The values in the <classname>&ns;::mime::sectioninfo</classname>
	    also get updated only when the show gets on the road.
	    <function>&ns;::mime::make_entity_parser</function>() takes the
	    <classname>&ns;::mime::sectioninfo</classname> object, and saves it
	    as
	    part of the returned output iterator, which updates the
	    &MIME; entity metadata in the
	    <classname>&ns;::mime::sectioninfo</classname> as the iterator
	    iterates over the output sequence. The iterator's reference on the
	    <classname>&ns;::mime::sectioninfo</classname> object gets released
	    only after the output iterator goes out of scope and gets
	    destroyed.
	  </para>

	  <para>
	    The values in the
	    <classname>&ns;::mime::sectioninfo</classname> may be used only
	    after
	    the output sequence iterates over the <literal>eof</literal> value.
	  </para>
	</listitem>
      </itemizedlist>
    </note>

    <para id="mimebodydecoder">
      The following example shows how to decode
      a non-compound &MIME; entity.
    </para>

    <blockquote>
      <title><ulink url="examples/mime/bodydecoder.C">examples/mime/bodydecoder.C</ulink></title>
      <informalexample>
	<programlisting><xi:include href="../examples/mime/bodydecoder.C" parse="text" xmlns:xi="http://www.w3.org/2001/XInclude" /></programlisting>
      </informalexample>
    </blockquote>

    <para>
      <filename>bodydecoder.C</filename> constructs a processor using a
      header collector that only cares about the
      <quote>Content-Transfer-Encoding</quote> and
      <quote>Content-Type</quote> headers, using
      a <ulink url="&namespace-x--chrcasecmp;">case-insensitive
	string comparison</ulink>.
      Proper parsing of these structured &MIME; headers requires an
      <link linkend="mimestructuredcontentheader"><classname>&ns;::mime::structured_content_header</classname></link>,
      even for the
      <quote>Content-Transfer-Encoding</quote>. This makes sure that any
      whitespace in the headers gets properly ignored.
      Once the &MIME;'s body begins, the body iterator construction lambda
      instantiates a
      <classname>&ns;::mime::section_decoder</classname> that
      outputs to a <classname>std::ostreambuf_iterator</classname> to
      <literal>std::cout</literal>.
      If <quote>Content-Type</quote> indicates that this is a
      <literal>text</literal> &MIME; entity, it also gets transcoded to
      <literal>UTF-8</literal>.
    </para>
    
    <computeroutput>
      <literallayout><![CDATA[
$ cat bodydecoder.txt
Subject: test
Content-Type: text/plain; charset=iso-8859-1
Content-Transfer-Encoding: quoted-printable

Hello=A0world!
$ ./bodydecoder <bodydecoder.txt
Hello]]>&nbsp;world!
104 bytes in the header, 15 bytes in the body.
4 lines in the header, 1 lines in the body.</literallayout>
    </computeroutput>

    <para>
      <filename>bodydecoder.C</filename> reads a non-compound &MIME;
      entity on standard input, and writes its decoded body to standard
      output.
    </para>

    <para>
      In this example, it's ok for the lambas
      to capture the stack-scoped objects,
      <varname>content_transfer_encoding</varname>,
      <varname>content_type</varname>, and
      <varname>charset</varname>, by reference. Everything gets iterated,
      and everything goes out of scope and gets destroyed, before
      <function>main</function>() returns.
      In most situations, it will be somewhat difficult to capture much
      by reference, and they'll capture everthing by value. Reference-counted
      objects come in very handy, under these circumstances.
    </para>

    <note>
      <para>
	The blank line that separates the header from the body is considered to
	be a part of the header portion of the &MIME; entity.
      </para>
    </note>
  </section>

  <section id="mimeentityparsercreate">
    <title>Creating &MIME; entity parsers</title>

    <para>
      The functions described in this section implement high level &MIME;
      parsing, by preparing the environment for
      <link linkend="mimeentityparser"><function>&ns;::mime::make_entity_parser</function></link>()
      using the appropriate context.
    </para>

    <para>
      These functions employ a <quote>section processor factory</quote>.
      This is a functor or a lambda that takes two parameters:
      a reference to the <link linkend="mimesectioninfo">section information
	object</link> and a <classname>bool</classname> flag.
    </para>

    <para>
      The section processor factory is expected to call
      <function>&ns;::mime::make_entity_parser</function>(), forwarding
      the <classname>&ns;::mime::sectioninfo</classname> to it, without further
      processing, and the section processor's return value is expected to be
      the output iterator
      that's returned by
      <function>&ns;::mime::make_entity_parser</function>().
    </para>

    <note>
      <para>
	After the section processor factory returns, the output iterator
	iterates over the contents of the &MIME; section.
	At the time the factory gets invoked, the
	<classname>&ns;::mime::sectioninfo</classname> is a freshly-constructed
	object, and does not yet reflect the &MIME; section's actual metrics.
      </para>

      <para>
	The <classname>&ns;::mime::sectioninfo</classname> object is complete
	only after the output iterator finishes iterating over the &MIME;
	section, including the trailing <literal>eof</literal>.
	The section processor factory can save this
	<classname>&ns;::mime::sectioninfo</classname>, which is
	a reference to a <link linkend="refobj">reference-counted object</link>,
	to be digested at a later time.
      </para>
    </note>

    <para>
      The <classname>bool</classname> flag is <literal>true</literal> when
      the section processor factory gets invoked to produce an output iterator
      for the top level &MIME; document section, or for the body of a
      <literal>message/rfc822</literal>.
      The section processor factory constructs an output iterator for
      the header portion of the &MIME; entity, and invokes 
      <function>&ns;::mime::make_entity_parser</function>(), passing it the
      header iterator as the first parameter.
      A <literal>true</literal>
      <classname>bool</classname> indicates whether the header iterator
      must find the <quote>Mime-Version: 1.0</quote> header, before recognizing
      any other &MIME; header. Pedantically,
      in absence of the <quote>Mime-Version: 1.0</quote> header, none of the
      <quote>Content</quote> headers should be considered as &MIME; header,
      and the message content should be treated as a non-&MIME;
      <literal>text/plain</literal> message.
    </para>

    <para>
      Otherwise, processor can safely assume that it's being invoked on behalf
      of a subsection of a &MIME; document that specified the header, and
      process all <quote>Content</quote> headers.
    </para>

    <para>
      <ulink url="&link-function-x--mime-make-document-entity-parser;"><function>&ns;::mime::make_document_entity_parser</function>()</ulink>
      constructs an output iterator over <literal>char</literal>s containing
      an entire &MIME; document.
      <function>&ns;::mime::make_document_entity_parser</function>()
      constructs an
      <link linkend="mimeparsernewlineiter"><classname>&ns;::mime::newline_iter</classname></link>
      that invokes the section factory object passed as the first parameter
      to <function>&ns;::mime::make_document_entity_parser</function>(), that
      sets up the output iterator over the entire &MIME; document.
    </para>

    <para>
      <function>&ns;::mime::make_document_entity_parser</function>()
      has two optional parameters:
    </para>

    <itemizedlist>
      <listitem>
	<para>
	  A <classname>bool</classname> parameter. The default
	  value of <literal>false</literal> specifies that the &MIME;
	  document uses the <literal>LF</literal> character as a newline
	  sequence. Setting this parameter to <literal>true</literal> specifies
	  that the &MIME; document uses the
	  <literal>CRLF</literal> newline character sequence.
	  This flag gets forwarded to
	  <classname>&ns;::mime::newline_iter</classname>'s constructor.
	</para>
      </listitem>

      <listitem>
	<para>
	  A <classname>bool</classname> parameter that's forwarded to the
	  section factory processor. The default <literal>true</literal>
	  value specifies that this is a traditional context where a &MIME;
	  document must have a <quote>Mime-Version: 1.0</quote> header.
	  A <literal>false</literal> value specifies a context where &MIME;
	  messages rule the roost (like <acronym>HTTP</acronym> messages, for
	  example).
	</para>
      </listitem>
    </itemizedlist>

    <para>
      After iterating using the output iterator returned by
      <function>&ns;::mime::make_document_entity_parser</function>(),
      its
      <link linkend="mimegeteof"><literal>get()-&gt;eof()</literal> method</link>
      gets invoked to signal the end of the iteration.
    </para>

    <para>
      <ulink url="examples/mime/bodydecoder2.C"><filename>examples/mime/bodydecoder2.C</filename></ulink>
      is a modified version of
      <link linkend="mimebodydecoder"><filename>bodydecoder.C</filename></link>
      that uses
      <function>&ns;::mime::make_document_entity_parser</function>()
      instead of manually constructing an
      <classname>&ns;::mime::newline_iter</classname> and invoking
      <function>&ns;::mime::make_entity_parser</function> directly.
    </para>
  </section>

  <section id="mimeentitycompoundparser">
    <title>Creating compound &MIME; entity parsers</title>
      
    <para>
      <link linkend="mimeentityparsercreate"><filename>bodydecoder.C</filename>
	and
      <filename>bodydecoder2.C</filename></link> lack the logic for handling
      compound &MIME; entities.
      <ulink url="&link-function-x--mime-make-multipart-parser;"><function>&ns;::mime::make_multipart_parser</function>()</ulink> and
      <ulink url="&link-function-x--mime-make-message-rfc822-parser;"><function>&ns;::mime::make_message_rfc822_parser</function>()</ulink>
      are section processor factories that wrap other
      section processor factories
      and return output iterators for parsing compound &MIME; sections.
      They get invoked from either
      the section processor factory that's passed to
      <link linkend="mimeentityparsercreate"><function>&ns;::mime::make_document_entity_parser</function></link>,
      or from another section processor factory that was previously
      wrapped by one of these functions.
      This results in an open-ended framework for recursively parsing
      compound &MIME; documents:
    </para>

    <blockquote>
      <title><ulink url="examples/mime/bodydecoder3.C">examples/mime/bodydecoder3.C</ulink></title>
      <informalexample>
	<programlisting><xi:include href="../examples/mime/bodydecoder3.C" parse="text" xmlns:xi="http://www.w3.org/2001/XInclude" /></programlisting>
      </informalexample>
    </blockquote>

    <para>
      <ulink url="&link-typedef-x--mime-contentheader-collector;"><classname>&ns;::mime::contentheader_collector</classname></ulink>
      is an output iterator that's similar to
      <link linkend="mimeheadercollector"><classname>&ns;::mimeheadercollector</classname></link>,
      except that it collects all headers whose names start with
      <quote>Content-</quote> into a
      <link linkend="headers"><classname>&ns;::headersbase</classname></link>.
    </para>

    <para>
      The output iterator's
      <link linkend="mimegeteof"><methodname>get</methodname> method</link>
      returns a reference to a reference-counted object with a
      <varname>content_headers</varname> member, which is a
      <classname>&ns;::headersbase</classname> container for the
      <quote>Content-</quote> headers.
      Additionally,
      <classname>&ns;::mime::contentheader_collector</classname>'s
      constructor takes a <classname>bool</classname> flag.
      If true, the <quote>Mime-Version: 1.0</quote> header must be present,
      otherwise no <quote>Content-</quote> headers get collected
      (<varname>content_headers</varname> will be empty).
    </para>

    <para>
      <quote>Mime-Version: 1.0</quote> can appear after the
      <quote>Content-</quote> headers.
      <classname>&ns;::mime::contentheader_collector</classname> collects all
      <quote>Content-</quote> headers as it iterates over the header portion
      of a &MIME; entity. At the end of the output sequence, the accumulated
      headers in <varname>content_headers</varname> get
      cleared if the <classname>bool</classname> flag
      is true but <quote>Mime-Version: 1.0</quote> was absent:
    </para>

    <computeroutput>
      <literallayout><![CDATA[
$ cat bodydecoder.txt
Subject: test
Content-Type: text/plain; charset=iso-8859-1
Content-Transfer-Encoding: quoted-printable

Hello=A0world!
$ ./bodydecoder3 <bodydecoder.txt
Hello=A0world!
MIME section 1 starts at character offset 0
  104 bytes in the header, 15 bytes in the body.
  4 lines in the header, 1 lines in the body.
]]></literallayout>
    </computeroutput>

    <para>
      In the absence of the <quote>Mime-Version: 1.0</quote> header, this is
      parsed as a non-&MIME; message, so the <literal>quoted-printable</literal>
      transfer encoding is not used, producing <quote>Hello=A0world</quote> on
      output.
    </para>

    <computeroutput>
      <literallayout><![CDATA[
$ cat bodydecoder2.txt
Subject: test
Content-Type: text/plain; charset=iso-8859-1
Content-Transfer-Encoding: quoted-printable
Mime-Version: 1.0

Hello=A0world!
$ ./bodydecoder3 <bodydecoder2.txt
Hello world!
MIME section 1 starts at character offset 0
  122 bytes in the header, 15 bytes in the body.
  5 lines in the header, 1 lines in the body.
]]></literallayout>
    </computeroutput>

    <para>
      Now the &MIME; headers are in effect.
    </para>

    <para>
      In <filename>bodydecoder3.C</filename> ,
      <function>create_parser</function> is the session processor factory
      functor/lambda that's passed to
      <function>&ns;::mime::make_document_entity_parser</function>,
      like
      <filename>bodydecoder.C</filename> and
      <filename>bodydecoder2.C</filename> (with a small wrapper that captures
      the top level <classname>&ns;::mime::sectioninfo</classname> object.
    </para>

    <para>
      <function>create_parser</function> constructs a new
      <classname>&ns;::mime::contentheader_collector</classname> object,
      and passes to <function>&ns;::mime::make_entity_parser</function>() as the
      header iterator.
    </para>

    <para>
      The body iterator factory captures the reference
      to the <link linkend="refobj">reference-counted</link> object with the
      <varname>content_headers</varname> by value, so that the object is still
      in scope long after <function>create_parser</function>() returns, when
      the header portion iteration concludes, at some time later.
      The body iterator factory parameter given to
      <function>&ns;::mime::make_entity_parser</function>() looks at the
      collected headers.
      <function>&ns;::mime::make_message_rfc822_parser</function>()
      takes a section processor functor/lambda and the
      <classname>&ns;::sectioninfo</classname> of a
      <literal>message/rfc822</literal> &MIME; entity, that invokes the
      section processor functor/lambda with a
      <classname>&ns;::sectioninfo</classname> for the body of the
      <literal>message/rfc822</literal> &MIME; entity.
      <filename>bodydecoder3.C</filename> passes the same
      <function>create_parser</function>() functor, effecting recursive
      parsing of these &MIME; entities.
    </para>

    <para>
      <function>&ns;::mime::make_multipart_parser</function>()
      takes three parameters: a delimiter for a <literal>multipart</literal>
      compound &MIME; entity, a session processor factory functor/lambda,
      and <literal>multipart</literal>'s
      <classname>&ns;::sectioninfo</classname>.
      It returns an output iterator that invokes the functor/lamba for
      every entity that the <literal>multipart</literal> entity contains.
    </para>

    <para>
      For non-compound &MIME; entities, the body iterator factory returns a
      <link linkend="mimeentityparser"><classname>&ns;::mime::section_decoder</classname></link>
      to decode the non-compound entity, converting <literal>text</literal>
      &MIME; entities to the <classname>UTF-8</classname> character set:
    </para>

    <computeroutput>
      <literallayout><![CDATA[
$ cat bodydecoder3.txt
Subject: test
Mime-Version: 1.0
Content-Type: multipart/mixed; boundary="xxx"

--xxx
Content-Type: text/plain; charset=iso-8859-1
Content-Transfer-Encoding: quoted-printable

Hello=A0
--xxx
Content-Type: text/plain; charset=iso-8859-1
Content-Transfer-Encoding: quoted-printable

world!

--xxx--
./bodydecoder <bodydecoder3.txt
Hello world!
MIME section 1 starts at character offset 0
  79 bytes in the header, 217 bytes in the body.
  4 lines in the header, 12 lines in the body.

MIME section 1.1 starts at character offset 85
  90 bytes in the header, 8 bytes in the body.
  3 lines in the header, 1 lines in the body.
  No trailing newline

MIME section 1.2 starts at character offset 190
  90 bytes in the header, 7 bytes in the body.
  3 lines in the header, 1 lines in the body.
]]></literallayout>
    </computeroutput>

    <para>
      <filename>bodydecoder3.C</filename> decodes each &MIME; entity in the
      document, one at a time, concatenating their contents.
      The first part of the <literal>multipart</literal> entity does not
      end with a trailing newline, so the result of the concatenation is a
      single line of text.
    </para>

    <para>
      <ulink url="examples/mime/bodydecoder4.C">examples/mime/bodydecoder4.C</ulink>
      is an alternative version of <filename>bodydecoder3.C</filename> that
      uses
      <ulink url="&link-function-x--mime-make-parser;"><function>&ns;::mime::make_parser</function></ulink>()
      to replace the logic in the first half of
      <function>parse_section</function>().
      The first parameter to <function>&ns;::mime::make_parser</function>() is a
      <classname>&ns;::mime::structured_content_header</classname> with the
      the value of the <quote>Content-Type</quote> header.
      The second parameter is the
      <classname>&ns;::sectioninfo</classname> for the &MIME; section where
      this <quote>Content-Type</quote> header came from.
      If it's a compound &MIME; section,
      <function>&ns;::mime::make_parser</function>() uses
      <function>&ns;::mime::make_multipart_parser</function>() or
      <function>&ns;::mime::make_message_rfc822_parser</function>() to take
      care of it, with the section processor factory passed as the third
      parameter.
      The fourth parameter is a functor or a lambda that gets invoked if
      the &MIME; section is not a compound section. It receives one argument,
      the <classname>&ns;::sectioninfo</classname>.
    </para>

  </section>
</chapter>

<!--
Local Variables:
mode: sgml
sgml-parent-document: ("book.xml" "part" "chapter")
End:
-->
