<!--

Copyright 2012 Double Precision, Inc.
See COPYING for distribution information.

-->

<chapter id="msgdispatcher">
  <title>Message dispatching-based thread design pattern</title>

  <para>
    <ulink url="&link-x--msgdispatcherObj;"><classname>&ns;::msgdispatcherObj</classname></ulink>
    is a <link linkend="refobj">reference-counted object</link> that implements
    a design pattern for a message-based thread class. An isolated thread
    runs in a loop that retrieves messages from other threads, and responds
    to them.
  </para>

  <para>
    This design pattern contains several elements.
  </para>

  <itemizedlist>
    <listitem>
      <para>
	An execution thread is associated with each instance of the
	class. The message dispatching classes discussed here are
	thread safe, and multiple execution threads can dispatch messages from
	the same class instance. However, this would typically complicate the
	design of the rest of the class, increasing the complexity required
	for thread safety. Having a single execution thread per class greatly
	reduces the complexity of implementing thread safety, since only one
	execution thread will have access to private class instance members.
      </para>
    </listitem>

    <listitem>
      <para>
	The class exports public methods that take their parameters and
	package them into a single instance of a message class.
	The public methods are called by other threads.
      </para>
    </listitem>

    <listitem>
      <para>
	The class maintains an internal thread-safe message queue.
	Each public method creates a message object, puts its parameters into
	the message object, and adds it to the message queue.
      </para>
    </listitem>

    <listitem>
      <para>
	The class implement overloaded 
	<methodname>dispatch</methodname>() methods that take a
	reference to
	each message class, as a parameter. They are private methods.
      </para>
    </listitem>

    <listitem>
      <para>
	The execution thread runs in a loop that takes messages off the
	internal queue, and invokes the associated
	<methodname>dispatch</methodname>() method.
      </para>
    </listitem>

    <listitem>
      <para>
	The execution thread gets terminated by throwing an exception in
	one of the <methodname>dispatch</methodname>() methods, that unwinds the
	stack and breaks out of the message dispatching loop.
      </para>
    </listitem>
  </itemizedlist>

  <para>
    <classname>&ns;::msgdispatcherObj</classname> implements the interface
    that constructs messages and puts them into a message queue by
    calling a pure virtual <methodname>event</methodname>(). A subclass
    implements <methodname>event</methodname>().
    There are two available implementations.
    <ulink url="&link-x--eventqueuemsgdispatcherObj;"><classname>&ns;::eventqueuemsgdispatcherObj</classname></ulink>
    is a subclass that uses an <link linkend="eventfd">event file
      descriptor</link>-based message queue and implemens
    <methodname>event</methodname> by putting the message into the
    event queue.
    <ulink url="&link-x--dequemsgdispatcherObj;"><classname>&ns;::dequemsgdispatcherObj</classname></ulink> is a subclass that uses a regular, mutex-protected,
    queue.
  </para>

  <para>
    Public methods comprise the public interface to the class. Public methods
    take their parameters and package them into messages which are added to the
    message queue.
    The thread runs a loop that takes messages off the queue, and invokes
    the overloaded <methodname>dispatch</methodname>() method.
  </para>

  <para>
    It's more convenient, in most situations, to use
    an <acronym>XSLT</acronym> stylesheet that takes a compact definitions
    of methods and their parameters.
    The stylesheet
    <link linkend="msgdispatchergen">generates the code</link> that defines
    the public methods which create the message classes, inserts the
    messages into the dispatching queue, and declares the
    <methodname>dispatch</methodname>() methods. The end result is conveniently
    <literal>#include</literal>d into the class definition.
    But before getting to that,
    the following examples demonstrate the
    inner workings of <classname>&ns;::msgdispatcherObj</classname>, and
    the mechanism that drives message dispatching.
  </para>

  <blockquote>
    <informalexample>
      <programlisting>
#include &lt;&ns;/dispatchablemsgobj.H&gt;

class myClass : public &ns;::eventqueuemsgdispatcherObj {

    class mystatus {

    public:

        bool format;

        mystatus(bool formatArg) : format(formatArg)
        {
        }

    };

    class myrefresh {

    public:

        std::string name;

        myrefresh(const std::string &amp;nameArg) : name(nameArg)
        {
        }

   };

  void dispatch(const mystatus &amp;msg);

  void dispatch(const myrefresh &amp;msg);

public:
  template&lt;typename obj_type, typename msg_type&gt;
      friend class &ns;::dispatchablemsgObj;

  void statusinquiry(bool longformat);

  void refresh(const std::string &amp;name);

  void run();
// ...

};

&ns;::ref&lt;myClass&gt; clinstance(&ns;::ref&lt;myClass&gt;::create());

&ns;::run(clinstance);</programlisting>
    </informalexample>
  </blockquote>

  <para>
    This simple class defines two messages,
    <quote>statusinquiry</quote> and <quote>refresh</quote>
    (there's also a default <quote>stop</quote> message inherited from
    <classname>&ns;::msgdispatcherObj</classname>),
    represented by two public methods.
  </para>

  <section id="msgdispatchersendevent">
    <title>Sending messages to the thread</title>

    <blockquote>
      <informalexample>
        <programlisting>
void myClass::statusinquiry(bool longformat)
{
    sendevent&lt;mystatus&gt;(this, longformat);
}

void myClass::refresh(const std::string &amp;name)
{
    sendevent&lt;myrefresh&gt;(this, name);

}</programlisting>
      </informalexample>
    </blockquote>

    <para>
      The <classname>&ns;::msgdispatcherObj</classname> superclass defines
      the <methodname>sendevent</methodname>() template method.
      Its template parameter specifies the message class to send
      to the message-dispatching thread. Each message is a separate class.
    </para>

    <para>
      The first parameter to <methodname>sendevent</methodname>() is a pointer
      to the class that defines the <methodname>dispatch</methodname>() method
      that receives the message class; in nearly all cases it's
      <literal>this</literal>. The pointer should not be an
      &reforptr;. In most cases, the message queue is a member of the
      subclass, and consists of &ref;s to unprocessed messages, and putting
      an &reforptr; in each message creates a circular reference.
    </para>

    <para>
      Using <literal>this</literal> is generally safe. If the
      message-dispatching
      object, and its thread, goes out of scope and gets destroyed, the
      unprocessed messages in the message queue also get destroyed, and their
      invalidated <literal>this</literal> never gets used.
    </para>

    <para>
      The remaining arguments to <methodname>sendevent</methodname> get
      forwarded to the constructed message class instance's constructor.
    </para>
  </section>

  <section id="msgdispatcherrun">
    <title>The message dispatching thread loop</title>

    <para>
      The subclass thread's <methodname>run</methodname>() method would
      typically
      consist of a loop that looks like this:
    </para>

    <blockquote>
      <informalexample>
	<programlisting>
#include &lt;&ns;/stopexception.H&gt;

void myClass::run()
{
    try {
        while (1)
        {
            msgqueue->pop()-&gt;dispatch();
        }
    } catch (const &ns;::stopexception &amp;)
    {
    }
}</programlisting>
      </informalexample>
    </blockquote>

    <para>
      In this example
      <ulink url="&link-x--eventqueuemsgdispatcherObj;"><classname>&ns;::eventqueuemsgdispatcherObj</classname></ulink>
      implements an event file descriptor-based message queue.
      The <varname>msgqueue</varname> class member is the event queue.
      <ulink url="&link-function-x-run;">&ns;::run</ulink>() starts a thread
      that runs the class's <methodname>run</methodname>() method that
      starts reading messages from the event queue, and invoking their
      <methodname>dispatch</methodname>() method.
    </para>

    <para>
      <methodname>sendevent</methodname> constructs
      <classname>&ns;::dispatchablemsgObj</classname>s and invokes
      <methodname>event</methodname>(), which gets implemented in
      <classname>&ns;::eventqueuemsgdispatcherObj</classname>.
      <methodname>event</methodname>() puts the messages into the queue,
      which <methodname>run</methodname>() drains.
    </para>

    <para>
      <classname>&ns;::dispatchablemsgObj</classname> instances contain
      messages, and the <literal>this</literal> that was passed to
      <methodname>sendevent</methodname>, that's typically the same object
      whose method is draining the message queue. Its
      <methodname>dispatch</methodname>() uses the stored
      <literal>this</literal> to invoke the overloaded
      <methodname>dispatch</methodname> methods.
    </para>

    <para>
      The overloaded <methodname>dispatch</methodname> methods are private
      methods, in this typical example, and may only be invoked by calling
      the public methods that queue up the messages to the thread.
      Subsequently, they get only invoked by the object's
      <methodname>run</methodname>() thread.
      As demonstrated by the example,
      <classname>&ns;::dispatchablemsgObj</classname> needs a friend
      declaration so it can invoke the private method.
    </para>

    <para>
      The message classes are also private inner classes, and can only
      be instanted by calling the public methods that queue up the messages
      to the class instance.
    </para>

    <para>
      For convenience, <classname>&ns;::msgdispatcherObj</classname>
      defines a <methodname>stop</methodname>() method that queues up a
      message that, when <methodname>dispatch</methodname>()ed, throws
      a <classname>&ns;::stopexception</classname>, as a means of terminating
      the message-dispatching thread.
      As shown in the previous example, this exception should be caught.
    </para>

    <formalpara>
      <title>Summary of the message dispatching-based thread design pattern</title>
      <para>
	<itemizedlist>
	  <listitem>
	    <para>
	      A subclass that's derived from
	      <classname>&ns;::msgdispatcherObj</classname>
	      that implements <methodname>event</methodname>() that places
	      prepackaged event messages into a queue
	      (or <classname>&ns;::eventqueuemsgdispatcherObj</classname>
	      that takes care of that using and event file descriptor-based
	      queue).
	      The subclass defines a <methodname>run</methodname>() that
	      conceptually implements:
	    </para>

	    <blockquote>
	      <informalexample>
		<programlisting>
while (1)
{
   msgqueue->pop()-&gt;dispatch();
}</programlisting>
	      </informalexample>
	    </blockquote>

	    <para>
	      <varname>msgqueue</varname> is an
	      <link linkend="eventqueue">event queue</link>
	      that gets instantiated by
	      <classname>&ns;::eventqueuemsgdispatcherObj</classname>.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      A collection of message classes, that can be private to the
	      subclass, and a corresponding collection of private
	      <methodname>dispatch</methodname> methods, overloaded with
	      a reference to a message class as their parameter.
	      The subclass declares that
	      <classname>&ns;::dispatchablemsgObj&lt;typename obj_type, typename msg_type&gt;</classname>
	      is its friend.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Public methods that invoke
	      <methodname>sendevent</methodname>() passing a message class
	      as a parameter to the template function, and
	      <varname>this</varname> as its first argument.
	      Any remaining arguments get forwarded to the message class's
	      constructor.
	    </para>

	    <para>
	      The public methods may be invoked by any thread, the
	      message class gets instantiated by
	      <methodname>sendevent</methodname>(), and sent to
	      the thread via <methodname>event</methodname>().
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      There are no specific requirements as to when the execution
	      thread needs to get started. Messages can be placed into its
	      internal queue before the thread gets started, and they
	      accumulate.
	    </para>

	    <para>
	      After the execution thread stops, the internal
	      message queue, and any remaining, undispatched messages, get
	      destroyed only when the message dispatching subclass itself
	      gets destroyed, so consider storing only weak references to the
	      message dispatching subclass.
	    </para>
	  </listitem>
	</itemizedlist>
      </para>
    </formalpara>
  </section>

  <section id="threadmsgstop">
    <title>Stopping the execution thread</title>

    <blockquote>
      <informalexample>
	<programlisting>

clinstance-&gt;stop();</programlisting>
      </informalexample>
    </blockquote>

    <para>
      <classname>&ns;::msgdispatcherObj</classname> subclasses
      <ulink url="&link-x--stoppableObj;"><classname>&ns;::stoppableObj</classname></ulink>
      and implements a
      <methodname>stop</methodname>() method which
      sends a message to the dispatcher thread that
      throws an exception when its <methodname>dispatch</methodname> gets invoked.
      Unless explicitly caught, the exception
      terminates the subclass's dispatch loop.
      This provides a convenient mechanism for stopping the dispatcher thread.
    </para>
  </section>

  <section id="stoppable">
    <title>Generic stoppable interface</title>

    <para>
      The thread message dispatcher's
      <link linkend="threadmsgstop"><methodname>stop</methodname>() method</link>
      is an implementation of the
      <ulink url="&link-typedef-x-stoppable;"><classname>&ns;::stoppable</classname></ulink>
      interface.
      The template class subclasses
      <ulink url="&link-x--stoppableObj;"><classname>&ns;::stoppableObj</classname></ulink>
      and implements <methodname>stop</methodname> that's defined by
      <classname>&ns;::stoppableObj</classname>. A typical implementation of
      a thread subclasses
      <link linkend="msgdispatcher"><classname>&ns;::msgdispatcherObj</classname></link>,
      but the implementation does not have to use <classname>&ns;::msgdispatcherObj</classname>,
      and subclass <classname>&ns;::stoppableObj</classname>, then implement
      <methodname>stop</methodname>() itself.
    </para>

    <para>
      When multiple threads are working together on the same task, sometimes
      it's desirable to coordinate their termination, as a group.
      Typical usage case would be having all threads terminate when any one of
      them terminates itself, or if a separate <quote>master</quote> thread
      terminates before they do.
      This is done by creating a group of stoppable objects.
    </para>

    <blockquote>
      <informalexample>
	<programlisting>
class mythreadObj : public &ns;::msgdispatcherObj {

// ...
};

typedef &ns;::ref&lt;mythreadObj&gt; mythread;

// ...

&ns;::stoppable::base::group sgroup=&ns;::stoppable::base::group::create();

mythread mainThread=mythread::create(), workerThread=mythread::create();

sgroup-&gt;add(mainThread);
sgroup-&gt;add(workerThread);

&ns;::ref&lt;&ns;::obj&gt; handle=&ns;::ref&lt;&ns;::obj&gt;::create();

sgroup-&gt;mcguffin(handle);

mythread extraThread=mythread::create();

sgroup-&gt;add(extraThread);</programlisting>
      </informalexample>
    </blockquote>

    <para>
      The stoppable group maintains a list of other objects that implement
      the stoppable interface. <methodname>add</methodname>() adds an object to the
      stoppable group. <methodname>mcguffin</methodname>() takes another object, and
      makes it a
      <link linkend="ondestroy">mcguffin</link>
      that results in each object in the stoppable group
      having its <methodname>stop</methodname>() method invoked when the mcguffin goes
      out of scope.
    </para>

    <para>
      In the above example, when <varname>mcguffin</varname> goes out of scope
      and gets destroyed, all objects in the stoppable group have their
      <methodname>stop</methodname>() invoked, including objects added to the group
      after a mcguffin's creation. In the above example,
      <varname>extraThread</varname> will also get <methodname>stop</methodname>()ed
      when the <varname>handle</varname> mcguffin goes out of scope.
    </para>

    <para>
      More than one mcguffin can be tied to a stoppable group. When any mcguffin
      goes out of scope and destroyed, all objects in the stoppable group
      get <methodname>stop</methodname>()ed.
    </para>

    <para>
      Once created, a stoppable group exists even if the
      <classname>&ns;::stoppable::base::group</classname>
      <link linkend="refobj">reference-counted object</link> goes out of scope.
      In the above example, even if <varname>sgroup</varname> goes out of scope,
      as long as one of its mcguffins still exists, somewhere, the mcguffin will
      do its duty and result in <methodname>stop</methodname>()age of object
      in the stoppable group.
    </para>

    <para>
      If you want all the members of a stoppable group getting
      <methodname>stop</methodname>()ed when the stoppable group reference
      goes out of scope, make the stoppable group its own mcguffin.
      If you want the stoppable group stopped when any object in the stoppable
      group goes out of scope and gets destroyed, pass the object to both
      <methodname>add</methodname>() and
      <methodname>mcguffin</methodname>().
      A stoppable group holds only weak references on the objects in the
      stoppable group; once any of them go out of scope naturally, and get
      destroyed, if it's also one of the group's mcguffins, all the other
      members of the stoppable group get <methodname>stop</methodname>()ed.
    </para>
  </section>

  <section id="msgdispatchergen">
    <title>Using a stylesheet to generate a thread-based message dispatching framework</title>

    <para>
      An <acronym>XSLT</acronym> stylesheet, usually installed as
      <filename>/usr/share/lib&ns;/msgdispatcher.xsl</filename> or
      <filename>/usr/local/share/lib&ns;/msgdispatcher.xsl</filename>, produces
      generic code for a message dispatching-based object from a stylesheet.
      An <acronym>XML</acronym> file defines the names of methods implemented
      by a class as a public interface, and the stylesheet generates the
      supporting code:
    </para>

    <blockquote>
      <informalexample>
	<programlisting><![CDATA[
<class name="errorthread">
  <method name="logerror" attributes='__attribute__((visibility("hidden")))'>
    <param><decl>const char *<name>file</name></decl></param>
    <param><decl>int <name>line</name></decl></param>
    <param type="class"><decl>std::string <name>error_message</name></decl></param>
  </method>

  <method name="report_errors">
    <param><decl>void (*<name>callback_func</name>)(const char *file, int line, const std::string &amp;errmsg)</decl></param>
  </method>
</class>
]]></programlisting>
      </informalexample>
    </blockquote>

    <para>
      Use an <acronym>XSLT</acronym> processor, such as
      <command>xsltproc</command> to run the stylesheet:
    </para>

    <blockquote>
      <informalexample>
	<programlisting>
$ xsltproc /usr/share/lib&ns;/msgdispatcher.xml errorthread.xml &gt;errorthread.inc.H</programlisting>
      </informalexample>
    </blockquote>

    <para>
      This results in the following contents of <filename>errorthread.inc.H</filename>
      (with some reformatting for readability):
    </para>

    <blockquote>
      <informalexample>
	<programlisting>
$ xsltproc /usr/share/lib&ns;/msgdispatcher.xml errorthread.xml<![CDATA[
// AUTOGENERATED -- do not edit

#ifndef lib]]>&ns;<![CDATA[_autogen_suppress_inner
private:

//! Internal message object sent by logerror()

class __attribute__((visibility("hidden"))) logerror_msg {
public:

//! Message parameter
  const char *file;

//! Message parameter
  int line;

//! Message parameter
  std::string error_message;

//! Message constructor

  logerror_msg(
    //! Parameter
    const char *file_arg,
    //! Parameter
    int line_arg, //! Parameter
    const std::string &error_message_arg) :
    file(file_arg),
    line(line_arg),
    error_message(error_message_arg)
  {
  }

//! Destructor

  ~logerror_msg() noexcept {}
};


//! Internal message object sent by report_errors()

class report_errors_msg {
public:

//! Message parameter
  void (*callback_func)(const char *file, int line, const std::string &errmsg);

//! Message constructor

  report_errors_msg(
    //! Parameter
    void (*callback_func_arg)(const char *file, int line, const std::string &errmsg)) :
    callback_func(callback_func_arg)
  {
  }

//! Destructor

  ~report_errors_msg() noexcept {}
};


public:
]]>
//! Send the logerrormessage to the class 

  void logerror(//! Parameter
                const char *file_arg,
                //! Parameter
                int line_arg, //! Parameter
                const std::string &amp;error_message_arg)
  {
    &ns;::msgdispatcherObj::sendevent&lt;logerror_msg&gt;(this, file_arg, line_arg, error_message_arg);
  }

//! Send the report_errorsmessage to the class 

  void report_errors(//! Parameter
                     void (*callback_func_arg)(const char *file, int line, const std::string &amp;errmsg))
  {
    &ns;::msgdispatcherObj::sendevent&lt;report_errors_msg&gt;(this, callback_func_arg);
  }


public:
  template&lt;typename obj_type, typename msg_type&gt;
      friend class &ns;::dispatchablemsgObj;

private:


//! Process message sent by logerror()

  void dispatch(const logerror_msg &amp;msg);

//! Process message sent by report_errors()

  void dispatch(const report_errors_msg &amp;msg);

#endif</programlisting>
      </informalexample>
    </blockquote>

    <para>
      This generated code gets inserted directly into a class declaration:
    </para>

    <blockquote>
      <informalexample>
	<programlisting>
#include &lt;string&gt;
#include &lt;&ns;/eventqueuemsgdispatcher.H&gt;

class errorthread : public &ns;::eventqueuemsgdispatcherObj {

#include "errorthread.inc.H"

public:
    void run();
};</programlisting>
      </informalexample>
    </blockquote>

    <para>
      <methodname>run</methodname>() would typically be the default
      message dispatching loop:
    </para>

    <blockquote>
      <informalexample>
	<programlisting>
void errorthread::run()
{
  while (1)
  {
    msgqueue->pop()-&gt;dispatch();
  }
}</programlisting>
      </informalexample>
    </blockquote>

    <para>
      All that's left is the actual implementation of the two
      <methodname>dispatch</methodname>() methods. The final product is a
      class with two public API methods:
      <methodname>logerror</methodname>() that takes a filename, a line number,
      and an error message string; and
      <methodname>report_errors</methodname>() that takes a callback function
      pointer.
    </para>

    <para>
      An internal class gets declared for each method:
      <classname><replaceable>method</replaceable>_msg</classname>.
      The <classname><replaceable>method</replaceable>_msg</classname> class
      holds the arguments of its public API method.
      Auto-generated public methods use
      <methodname>sendevent</methodname>
      to dispatch internal classes to the therad.
    </para>

    <para>
      The end result: define the method names and their parameters in the
      <acronym>XML</acronym> definition file, the stylesheet generates the
      stub code for those methods, that puts the arguments into a
      <classname><replaceable>method</replaceable>_msg</classname> object, then
      implement a <methodname>dispatch</methodname>() method that takes a
      <literal>const</literal> reference to a
      <classname><replaceable>method</replaceable>_msg</classname>.
    </para>

    <section id="msgdispatchergenparam">
      <title>Stylesheet parameters</title>

      <para>
	The <filename>msgdispatcher.xsl</filename> stylesheet takes
	several parameters:
      </para>

      <variablelist>
	<varlistentry>
	  <term><varname>mode</varname></term>
	  <listitem>
	    <para>
	      This parameter defines the content to produce from the stylesheet.
	      The allowed values are:
	    </para>

	    <variablelist>
	      <varlistentry>
		<term><quote><literal>all</literal></quote></term>
		<listitem>
		  <para>
		    The default value, generates everything: message class
		    declarations, public API function declaration and
		    their content, which creates the message class instance
		    and invokes <methodname>event</methodname>() to put it into
		    the message queue.
		  </para>
		</listitem>
	      </varlistentry>

	      <varlistentry>
		<term><quote><literal>messagedecl</literal></quote></term>
		<listitem>
		  <para>
		    Generate only message class declarations, only
		    <quote>class <replaceable>method</replaceable>_msg;</quote>.
		  </para>
		</listitem>
	      </varlistentry>

	      <varlistentry>
		<term><quote><literal>messagedef</literal></quote></term>
		<listitem>
		  <para>
		    Generate the complete definitions of all the message
		    classes, their constructors and destructors.
		  </para>
		</listitem>
	      </varlistentry>

	      <varlistentry>
		<term><quote><literal>apidecl</literal></quote></term>
		<listitem>
		  <para>
		    Generate declarations of public methods, only
		    <quote>void <replaceable>method</replaceable>( <replaceable>arguments</replaceable> )</quote>.
		  </para>
		</listitem>
	      </varlistentry>

	      <varlistentry>
		<term><quote><literal>apidef</literal></quote></term>
		<listitem>
		  <para>
		    Generate complete definition of the public methods,
		    including their contents, that instantiates the message
		    class and invokes <methodname>event</methodname>().
		  </para>
		</listitem>
	      </varlistentry>

	      <varlistentry>
		<term><quote><literal>dispatch</literal></quote></term>
		<listitem>
		  <para>
		    Declare <methodname>dispatch</methodname>() methods that
		    receive messages queued up by the public API methods.
		  </para>
		</listitem>
	      </varlistentry>

	      <varlistentry>
		<term><quote><literal>decl</literal></quote></term>
		<listitem>
		  <para>
		    This equivalent to
		    <literal>messagedecl</literal>,
		    <literal>apidecl</literal>, and
		    <literal>dispatch</literal>.
		  </para>
		</listitem>
	      </varlistentry>

	      <varlistentry>
		<term><quote><literal>def</literal></quote></term>
		<listitem>
		  <para>
		    This equivalent to
		    <literal>messagedef</literal> and
		    <literal>apidef</literal>.
		  </para>
		</listitem>
	      </varlistentry>
	    </variablelist>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>scope</varname></term>
	  <listitem>
	    <para>
	      This parameter has two values, <quote>inner</quote> the default
	      value, and <quote>outer</quote> which adds the name of the
	      class in the generated code.
	      Using the previous example, and running the stylesheet with the
	      <literal>mode</literal> parameter set to
	      <literal>messagedef</literal> produces
	      the following code:
	    </para>

	    <blockquote>
	      <informalexample>
		<programlisting><![CDATA[
// AUTOGENERATED -- do not edit

#ifndef lib]]>&ns;<![CDATA[_autogen_suppress_inner

//! Internal message object sent by logerror()

class __attribute__((visibility("hidden"))) logerror_msg {
public:

  //! Message parameter
  const char *file;

  //! Message parameter
  int line;

  //! Message parameter
  std::string error_message;

  //! Message constructor

  logerror_msg(//! Parameter
               const char *file_arg, //! Parameter
               int line_arg, //! Parameter
               const std::string &error_message_arg) :
    file(file_arg),
    line(line_arg),
    error_message(error_message_arg) {}

  //! Destructor

  ~logerror_msg() noexcept {}
};

//! Internal message object sent by report_errors()

class report_errors_msg {
public:

  //! Message parameter
  void (*callback_func)(const char *file, int line, const std::string &errmsg);

  //! Message constructor

  report_errors_msg(//! Parameter
                    void (*callback_func_arg)(const char *file,
                                              int line,
                                              const std::string &errmsg)) :
    callback_func(callback_func_arg) {}

  //! Destructor

  ~report_errors_msg() noexcept {}
};
#endif]]></programlisting>
	      </informalexample>
	    </blockquote>

	    <para>
	      Setting <literal>scope</literal> to <literal>outer</literal>
	      in addition with
	      <literal>mode</literal> set to
	      <literal>messagedef</literal> produces
	      the following:
	    </para>

	    <blockquote>
	      <informalexample>
		<programlisting><![CDATA[
// AUTOGENERATED -- do not edit

#ifndef lib]]>&ns;<![CDATA[_autogen_suppress_outer

//! Internal message object sent by logerror()

class __attribute__((visibility("hidden"))) errorthread::logerror_msg {
public:

//! Message parameter
  const char *file;

//! Message parameter
  int line;

//! Message parameter
  std::string error_message;

//! Message constructor

  logerror_msg(//! Parameter
const char *file_arg, //! Parameter
int line_arg, //! Parameter
const std::string &error_message_arg) :
    file(file_arg),
    line(line_arg),
    error_message(error_message_arg) {}

//! Destructor

  ~logerror_msg() noexcept {}
};


//! Internal message object sent by report_errors()

class errorthread::report_errors_msg {
public:

//! Message parameter
  void (*callback_func)(const char *file, int line, const std::string &errmsg);

//! Message constructor

  report_errors_msg(//! Parameter
void (*callback_func_arg)(const char *file, int line, const std::string &errmsg)) :
    callback_func(callback_func_arg) {}

//! Destructor

  ~report_errors_msg() noexcept {}
};
#endif]]></programlisting>
	      </informalexample>
	    </blockquote>

	    <note>
	      <para>
		With <literal>mode</literal> set to
		<literal>def</literal>, the
		<literal>scope</literal> parameter is ignored, and
		presumed to be set to <literal>outer</literal>.
	      </para>
	    </note>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term><varname>messages</varname> and
	  <varname>dispatch</varname></term>
	  <listitem>
	    <para>
	      These parameters are set to either
	      <quote>public</quote>, <quote>protected</quote>, or
	      <quote>private</quote> (the default for both).
	      These parameters are used when
	      <literal>mode</literal> is
	      <literal>all</literal> or
	      <literal>decl</literal>. These parameters specify whether
	      the generated code declares the message classes and the
	      <methodname>dispatch</methodname>() methods as
	      <quote>public:</quote> or <quote>private:</quote>.
	    </para>

	    <para>
	      If <literal>dispatch</literal> is not <quote>public</quote>
	      the stylesheet produces
	      a friend declaration for
	      <classname>&ns;::dispatchablemsgObj&lt;typename obj_type, typename msg_type&gt;</classname>
	      when <literal>mode</literal> is
	      <quote>all</quote> or
	      <quote>decl</quote>, so that
	      it is able to invoke
	      the <methodname>dispatch</methodname>() methods.
	    </para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>
	Check your <acronym>XSLT</acronym> processor's documentation for
	instructions on setting stylesheet parameters.
	With <command>xsltproc</command>, use the <option>--stringparam</option>
	option:
      </para>

      <blockquote>
	<informalexample>
	  <programlisting>
xsltproc --stringparam mode messagedef --stringparam scope outer /usr/share/lib&ns;/msgdispatcher.xml errorthread.xml</programlisting>
	</informalexample>
      </blockquote>
    </section>

    <section id="msgdispatcherxml">
      <title>XML definitions</title>

      <para>
	Using the same <acronym>XML</acronym> file as an example:
      </para>

      <blockquote>
	<informalexample>
	  <programlisting><![CDATA[
<class name="errorthread">
  <method name="logerror">
    <param><decl>const char *<name>file</name></decl></param>
    <param><decl>int <name>line</name></decl></param>
    <param type="class"><decl>std::string <name>error_message</name></decl></param>
  </method>

  <method name="report_errors">
    <param><decl>void (*<name>callback_func</name>)(const char *file, int line, const std::string &amp;errmsg)</decl></param>
  </method>
</class>
]]></programlisting>
	</informalexample>
      </blockquote>

      <para>
	The
	<literal>&lt;class&gt;</literal>
	element has a required <quote>name</quote> attribute that gives the
	name of the class for the generated methods, and contains one or more
	<literal>&lt;method&gt;</literal> elements.
      </para>

      <para>
	Each
	<literal>&lt;method&gt;</literal>
	has a required attribute, <quote>name</quote> that's essentially the
	name of the public API method, and
	contains an optional <literal>&lt;comment&gt;</literal> element,
	and a list of
	<literal>&lt;param&gt;</literal>
	elements, one for each parameter to the public API function.
	This list may be empty, if the public API function takes no parameters.
      </para>

      <para>
	<literal>&lt;method&gt;</literal>
	has an optional <quote>attributes</quote> parameter that, if present
	gets inserted immediately after the class keyword, verbatim. This is
	typically used to set <command>gcc</command> extensions on a class
	declaration.
      </para>

      <para>
	<literal>&lt;param&gt;</literal> has an optional
	<literal>&lt;comment&gt;</literal> element, and a required
	<literal>&lt;decl&gt;</literal>
	element that contains a literal declaration of a C++ variable,
	with the variable's name marked with a
	<literal>&lt;name&gt;</literal> element (and without a trailing
	semicolon).
      </para>

      <para>
	As shown in the example with the generated code, each parameter
	to a public API method get stored into a message class, with
	the definition of class members taken literally from the
	<literal>&lt;param&gt;</literal>
	elements.
      </para>

      <para>
	Setting the optional
	<literal>&lt;param&gt;</literal>
	attribute <quote>type</quote> to <quote>class</quote> indicates
	that the parameter definition is a class definition, and that the
	constructor in the generated code for the public API method, and
	the message class's constructor, receives the parameter as a constant
	reference.
      </para>

      <blockquote>
	<informalexample>
	  <programlisting><![CDATA[
<method name="logerror">
  <param><decl>const char *<name>file</name></decl></param>
  <param><decl>int <name>line</name></decl></param>
  <param><decl>std::string <name>error_message</name></decl></param>
</method>]]></programlisting>
	</informalexample>
      </blockquote>

      <para>
	This generates the followeing public API declaration.
      </para>

      <blockquote>
	<informalexample>
	  <programlisting><![CDATA[
void logerror(const char *file_arg, int line_arg,
              std::string error_message_arg)]]></programlisting>
	</informalexample>
      </blockquote>

      <para>
	Setting <varname>error_message</varname>'s
	<literal>&lt;param&gt;</literal>'s
	<quote>type</quote> attribute to <quote>class</quote> changes this to:
      </para>

      <blockquote>
	<informalexample>
	  <programlisting><![CDATA[
void logerror(const char *file_arg, int line_arg,
              const std::string &error_message_arg)]]></programlisting>
	</informalexample>
      </blockquote>

      <para>
	Setting 
	<literal>&lt;param&gt;</literal>
	to <quote>type</quote> to <quote>weakptr</quote> passes &ptr;s
	to <link linkend="refobj">reference-counted objects</link>
	as <link linkend="weakptr">weak references</link>:
      </para>

      <blockquote>
	<informalexample>
	  <programlisting><![CDATA[
<method name="report_errors">
  <param type="weakptr"><decl>]]>mcguffinptr <![CDATA[<name>mcguffin</name></decl></param>
</method>]]></programlisting>
	</informalexample>
      </blockquote>

      <para>
	This generates the following message class (slightly reformatted
	for readability):
      </para>

      <blockquote>
	<informalexample>
	  <programlisting><![CDATA[
// AUTOGENERATED -- do not edit

#ifndef lib]]>&ns;<![CDATA[_autogen_suppress_inner
private:


//! Internal message object sent by report_errors()

class report_errors_msg {
public:

  //! Message parameter
  ]]>&ns;<![CDATA[::weakptr<mcguffinptr> mcguffin;

  //! Message constructor

  report_errors_msg(//! Parameter
                    const mcguffinptr &mcguffin_arg) :
                    mcguffin(mcguffin_arg)
  {
  }

  //! Destructor

  ~report_errors_msg() noexcept {}
};


public:

  //! Send the report_errorsmsg to the class 

  void report_errors(//! Parameter
                     const mcguffinptr &mcguffin_arg)
  {
    ]]>&ns;<![CDATA[::msgdispatcherObj::sendevent<report_errors_msg>(this, mcguffin_arg);
  }


public:
  ]]>template&lt;typename obj_type, typename msg_type&gt;
      friend class &ns;::dispatchablemsgObj;<![CDATA[

private:


//! Process message sent by report_errors()

  void dispatch(const report_errors_msg &msg);

#endif]]></programlisting>
	</informalexample>
      </blockquote>

      <para>
	The stylesheet generates code that declares the parameter as a
	reference to the specified &ptr;,
	but the message stores a weak reference.
	The parameter declared with a <literal>weakptr</literal>
	should always be a &ptr;. Here, for example, the declaration
	<quote>typedef &ns;::ptr&lt;&ns;::obj&gt; mcguffinptr;</quote>
	should be somewhere in scope.
      </para>

      <para>
	This is useful when the actual parameter to the API call is a
	reference to a reference-counted object, and the executing
	thread terminates without processing the message, but something else
	holds a reference on the thread object preventing it from being
	destroyed. Since the message on the dead thread's message queue contains
	only a weak reference this won't prevent the parameter to the
	API call from being destroyed if no other references to it exist.
      </para>

      <para>
	The <methodname>dispatch</methodname>() method is expected to recover
	a strong reference, when it picks up the message, and have a
	well-defined error path if the weakly-referenced object has already
	been destroyed.
      </para>

      <note>
	<para>
	  Specifying that a parameter is a weak reference implies that the
	  caller retains the reference to the parameter object, after
	  the API call completes. Otherwise, with the API call complete, the
	  caller's reference to the object goes out of scope may go out of
	  scope, and the referenced object gets destroyed, before the executing
	  thread has a chance to recover a strong reference to the parameter
	  object.
	</para>
      </note>

      <para>
	<literal>&lt;method&gt;</literal> 
	has an optional <quote>virtual</quote> attribute:
      </para>

      <blockquote>
	<informalexample>
	  <programlisting><![CDATA[
<method name="report_errors" virtual="1">
  <param type="weakptr"><decl>]]>mcguffinptr <![CDATA[<name>mcguffin</name></decl></param>
</method>]]></programlisting>
	</informalexample>
      </blockquote>

      <para>
	The <quote>virtual</quote> attribute results in the
	<methodname>dispatch</methodname>() method getting declared as a virtual
	method:
      </para>

      <blockquote>
	<informalexample>
	  <programlisting><![CDATA[
//! Process message sent by report_errors()

  virtual void dispatch(const report_errors_msg &msg);]]></programlisting>
	</informalexample>
      </blockquote>

    </section>

    <section id="msgdispatchercons">
      <title>Optional message class constructor and serialization function</title>
      <para>
	The
	<literal>&lt;method&gt;</literal>
	element has an optional
	<quote>default</quote> attribute that may be set to <quote>1</quote>:
      </para>

      <blockquote>
	<informalexample>
	  <programlisting><![CDATA[
<method name="dump" default="1" serialize="1">
  <param type="class"><decl>std::string <name>filename</name></decl></param>
  <param default="0"><decl>int <name>count</name></decl></param>
  <param default="1"><decl>int <name>repeat</name></decl></param>
  <param type="class" dontserialize="1"><decl>]]>&ns;::ptr&amp;lt;&ns;::obj&amp;gt;<![CDATA[ <name>mcguffin</name></decl></param>
</method>]]></programlisting>
	</informalexample>
      </blockquote>

      <para>
	This adds a default constructor to the definition of the generated
	message class.
	Each
	<literal>&lt;param&gt;</literal>'s
	optional <quote>default</quote> atribute gives the value for the
	message class's member that's initialized by the default constructor.
      </para>

      <para>
	Finally, setting
	<literal>&lt;method&gt;</literal>'s
	<quote>serialize</quote> attribute to <quote>1</quote> generates a
	<link linkend="serializingclasses"><methodname>serialize</methodname>()</link>
	method in the message class definition, serializing all parameters
	except ones that have the <quote>dontserialize</quote> attribute
	set to <quote>1</quote>.
	The <filename>msgdispatcher.xsl</filename> stylesheet
	produces the following code from the above
	<acronym>XML</acronym> definition:</para>

      <blockquote>
	<informalexample>
	  <programlisting><![CDATA[
// AUTOGENERATED -- do not edit

#ifndef lib]]>&ns;<![CDATA[_autogen_suppress_inner
private:


//! Internal message object sent by dump()

class dump_msg {
public:

//! Message parameter
  std::string filename;

//! Message parameter
  int count;

//! Message parameter
  int repeat;

//! Message parameter
  ]]>&ns;<![CDATA[::ptr<]]>&ns;<![CDATA[::obj> mcguffin;

//! Message constructor

  dump_msg(//! Parameter
           const std::string &filename_arg,
           //! Parameter
           int count_arg,
           //! Parameter
           int repeat_arg,
           //! Parameter
           const ]]>&ns;<![CDATA[::ptr<]]>&ns;<![CDATA[::obj> &mcguffin_arg) :
    filename(filename_arg),
    count(count_arg),
    repeat(repeat_arg),
    mcguffin(mcguffin_arg)
  {
  }

  //! Default constructor

  dump_msg() :
      count(0),
      repeat(1)
  {
  }

  //! Serialization function

  template<typename iter_type> void serialize(iter_type &iter)
  {
    iter(filename);
    iter(count);
    iter(repeat);
  }

  //! Destructor

  ~dump_msg() noexcept {}
};


public:

//! Send the dumpmessage to the class 

  void dump(//! Parameter
            const std::string &filename_arg,
            //! Parameter
            int count_arg,
            //! Parameter
            int repeat_arg,
            //! Parameter
            const ]]>&ns;<![CDATA[::ptr<]]>&ns;<![CDATA[::obj> &mcguffin_arg)
  {
    ]]>&ns;<![CDATA[::msgdispatcherObj::sendevent<dump_msg>(this, filename_arg, count_arg, repeat_arg, mcguffin_arg);
  }


public:
  ]]>template&lt;typename obj_type, typename msg_type&gt;
      friend class &ns;::dispatchablemsgObj;<![CDATA[

private:


//! Process message sent by dump()

  void dispatch(const dump_msg &msg);

#endif]]></programlisting>
	</informalexample>
      </blockquote>
    </section>

    <section id="msgdispatcherdoxygen">
      <title>Generating <application>doxygen</application> documentation</title>

      <para>
	<literal>&lt;comment&gt;</literal> elements in
	<literal>&lt;method&gt;</literal> and
	<literal>&lt;param&gt;</literal> provide a mechanism for
	inserting <application>Doxygen</application> tags:
      </para>

      <blockquote>
	<informalexample>
	  <programlisting><![CDATA[
  <method name="write">
    <comment>/*!
    Write an object
    */</comment>

    <param type="class">
      <comment>/*!
      Object to be written
      */</comment>
    <decl>objref <name>object</name></decl></param>
  </method>]]></programlisting>
	</informalexample>
      </blockquote>

      <para>
	The resulting output from the stylesheet looks like this
	(reformatted for readability).
      </para>
      <blockquote>
	<informalexample>
	  <programlisting>
// AUTOGENERATED -- do not edit

#ifndef lib&ns;_autogen_suppress_inner

/* ... */

/*!
    Write an object
*/

  void write(/*!
             Object to be written
             */

             const objref &amp;object_arg)
  {

/* ... */

#endif</programlisting>
	</informalexample>
      </blockquote>

      <para>
	The partial code fragment containing this output is typically
	saved in a separate <filename>.H</filename> file and the
	<filename>.H</filename> that declares the class
	<literal>#include</literal>d from inside the class.
	<application>Doxygen</application> typically parses the main
	class file, but also attempts to read the standalone
	<filename>.H</filename> file with the auto-generated code, resulting
	in mild chaos.
      </para>

      <para>
	For this reason, the autogenerated code is wrapped inside the
	<literal>ifndef/endif</literal> construct, as shown above.
	In the <filename>Doxyfile</filename> specify
	<quote>PREDEFINED = lib&ns;_autogen_suppress_inner</quote> accordingly,
	so <application>Doxygen</application> doesn't see it, but also
	add <quote>#undef lib&ns;_autogen_suppress_inner</quote> in the
	<filename>.H</filename> file with the main class definition, so that
	the <quote>#include</quote> from the class <filename>.H</filename>
	gets parsed.
      </para>

      <para>
	Depending on whether autogenerated code uses outer scope, and how
	the autogenerated code gets included, predefining
	<varname>lib&ns;_autogen_suppress_outer</varname> may also be
	necessary.
      </para>
    </section>

    <section id="msgdispatchermake">
      <title><application><acronym>GNU</acronym> make</application> macros</title>
      &automakeintro;

      <blockquote>
	<informalexample>
	  <programlisting>
include /usr/share/lib&ns;/libcxx.mk

$(call MSGDISPATCHER_GEN,errorlog,all)</programlisting>
	</informalexample>
      </blockquote>

      <para>
	This example creates a rule for the target
	<filename>errorlog.all.H</filename>
	with a dependency <filename>errorlog.xml</filename>.
	The target gets created by running the
	<filename>msgdispatcher.xsl</filename> stylesheet with the
	<quote>mode</quote> parameter set to <quote>all</quote>.
	An optional third parameter to
	<methodname>MSGDISPATCHER_GEN</methodname> is a list of other
	<quote>parameter=value</quote> settings that are passed to
	<command>xsltproc</command> using the <option>--stringparam</option>
	option:
      </para>

      <blockquote>
	<informalexample>
	  <programlisting>
$(call MSGDISPATCHER_GEN,errorlog,all,dispatch=public)</programlisting>
	</informalexample>
      </blockquote>

      <para>
	Another useful invocation of
	<methodname>MSGDISPATCHER_GEN</methodname> generates declarations
	and definitions into separate files:
      </para>

      <blockquote>
	<informalexample>
	  <programlisting>
$(call MSGDISPATCHER_GEN,errorlog,decl def)</programlisting>
	</informalexample>
      </blockquote>

      <para>
	This macro creates two make targets,
	<filename>errorlog.decl.H</filename> and
	<filename>errorlog.def.H</filename>, with the
	same dependency,
	<filename>errorlog.xml</filename>,
	that get created by running
	the
	<filename>msgdispatcher.xsl</filename> stylesheet with the
	<quote>mode=decl</quote> and <quote>mode=def</quote> parameters.
      </para>
    </section>

    <section id="msgdispatcherautomake">
      <title>Using <acronym>GNU</acronym> <application>make</application> macros with <application>automake</application></title>

      <para>
	In <filename>configure.ac</filename>:
      </para>

      <blockquote>
	<informalexample>
	  <programlisting>
LIBCXX_INIT</programlisting>
	</informalexample>
      </blockquote>

      <para>
	In <filename>Makefile.am</filename>:
      </para>

      <blockquote>
	<informalexample>
	  <programlisting>
@LIBCXX_AM@

# Followed by macro calls:

$(call MSGDISPATCHER_GEN,errorlog,all)

# ...
</programlisting>
	</informalexample>
      </blockquote>

      &automakelibxinit;

    </section>
  </section>

  <section id="msgdispatchermcguffins">
    <title>Using mcguffins with a message dispatching-based thread</title>

    <para>
      The message-dispatching framework,
      including the
      <link linkend="msgdispatchergen">stylesheet-generated one</link>
      works conveniently with
      <link linkend="ondestroy">mcguffins</link>.
      The public method simply takes a mcguffin reference
      as one of its parameters,
      which gets placed into the message class instance.
      After the <methodname>dispatch</methodname>() function gets the message
      as one of its parameters, and returns, the message class instance,
      with the mcguffin reference quietly sitting there, gets destroyed,
      releasing the reference to the mcguffin.
    </para>

    <para>
      Another parameter to the public method would also be a reference
      to another object that would represent some kind of the return value,
      or the result status of processing the message. Presumably, there
      won't be any other reference to the mcguffin parameter, so after the
      thread is done with the message, the mcguffin's destructor (or a
      separate destructor callback) can examine the return value object.
    </para>

    <para>
      Its important to understand the implications of the mcguffin-based
      approach. Until the executing thread gets around to grabbing the
      message off its queue, to dispatch, the message class queued up
      by the public method waits in the internal queue.
      The thread could terminate before the message gets dispatched,
      and messages will remain in the internal queue.
      The recommended approach mentioned earlier suggests using only
      weak references to thread-based message dispatching subclasses, so when
      the executing thread terminates, the return value object would indicate
      that the message was not processed (the return value object is
      presumably instantiated indicating that the corresponding message
      is not processed).
    </para>
  </section>
</chapter>
<!--
Local Variables:
mode: sgml
sgml-parent-document: ("book.xml" "book" "chapter")
End:
-->
