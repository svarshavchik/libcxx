<!--

Copyright 2014 Double Precision, Inc.
See COPYING for distribution information.

-->

<chapter id="functional">
  <title>Virtual inheritance-based function objects</title>

  <blockquote>
    <informalexample>
      <programlisting>
#include &lt;&ns;/functional.H&gt;

int method(const &ns;::function&lt;int(const char *)&gt; &amp;func)
{
    return func("Hello world");
}

// ...

template&lt;typename functor_type&gt;
int call_method(functor_type &amp;&amp; functor)
{
    auto f=&ns;::make_function&lt;int(const char *)&gt;(std::forward&lt;functor_type&gt;(functor));

    return method(f);
}</programlisting>
    </informalexample>
  </blockquote>

  <para>
    This is a mechanism for implementing function objects
    for type-erasing lambdas which uses
    virtual inheritance instead of heap allocation, like
    <classname>std::function</classname>.
    <ulink url="&link-x--function--return-type-Args...--;"><classname>&ns;::function&lt;return_type(Args...)&gt;</classname></ulink>
    is a function object that implements an <methodname>operator()</methodname>
    that takes <replaceable>Args...</replaceable> parameters and returns a
    <replaceable>return_type</replaceable>, like
    <classname>std::function</classname>.
    <ulink url="&link-function-x-make-function;"><function>&ns;::make_function&lt;return_type(Args...)&gt;</function></ulink>()
    takes a functor parameter, and returns a subclass of
    <classname>&ns;::function&lt;return_type(Args...)&gt;</classname>
    that implements the <methodname>operator()</methodname> by invoking
    the functor.
  </para>

  <para>
    The two main ways to use <classname>&ns;::function</classname>:
  </para>

  <orderedlist>
    <listitem>
      <para>
	Call <function>&ns;::make_function&lt;return_type(Args...)&gt;</function>() and pass its return
	value as a <classname>const &ns;::function&lt;return_type(Args...)&gt; &amp;</classname> parameter.
      </para>
    </listitem>

    <listitem>
      <para>
	Call <function>&ns;::make_function&lt;return_type(Args...)&gt;</function>()
	and store its return value in an <classname>auto</classname>
	variable, that's subsequently passed as a
	<classname>const &ns;::function&lt;return_type(Args...)&gt; &amp;</classname> function parameter.
      </para>
    </listitem>
  </orderedlist>

  <section id="functionalref">
    <title>Function references</title>

    <para>
      <ulink url="&link-typedef-x-functionref;"><classname>&ns;::functionref</classname></ulink>
      and
      <ulink url="&link-typedef-x-functionptr;"><classname>&ns;::functionptr</classname></ulink>,
      together with
      <ulink url="&link-function-x-make-functionref;"><function>&ns;::make_functionref</function></ulink>,
      provide a <link linkend="refobj">reference-counted</link> wrapper for
      an
      <link linkend="functional"><classname>&ns;::function&lt;return_type(Args...)&gt;</classname></link>.
      Like <classname>std::function</classname>, this ends up using
      dynamic memory allocation, but you get all the reference-counted goodies:
    </para>

    <blockquote>
      <informalexample>
	<programlisting>
#include &lt;&ns;/functionalref.H&gt;

int method(const &ns;::function&lt;int(const char *)&gt; &amp;func)
{
    return func("Hello world");
}

// ...

template&lt;typename functor_type&gt;
int call_method(functor_type &amp;&amp; functor)
{
    &ns;::functionref&lt;int(const char *)&gt; f=&ns;::make_functionref&lt;int(const char *)&gt;(std::forward&lt;functor_type&gt;(functor));

    &ns;::function&lt;int(const char *)&gt; &amp;fr = *f;

    return method(fr) + f-&gt;invoke("!");
}</programlisting>
      </informalexample>
    </blockquote>

    <para>
      <ulink url="&link-typedef-x-functionref;"><classname>&ns;::functionref</classname></ulink>
      is a reference to an
      <link linkend="obj">obj</link> that inherits from an
      <classname>&ns;::function</classname>.
      Although its <methodname>operator()</methodname> is available,
      it's more convenient to use its <methodname>invoke</methodname>()
      method, which is just a wrapper for its
      <methodname>operator()</methodname>().
    </para>
  </section>
</chapter>
<!--
Local Variables:
mode: sgml
sgml-parent-document: ("book.xml" "part" "chapter")
End:
-->
