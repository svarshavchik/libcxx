<!--

Copyright 2012 Double Precision, Inc.
See COPYING for distribution information.

-->

<chapter id="stringability">
  <title>String conversions</title>

  <blockquote>
    <informalexample>
      <programlisting>
#include &lt;&ns;/value_string.H&gt;
#include &lt;&ns;/locale.H&gt;

&ns;::locale l;

std::string s;

std::wstring ws;

short n;

// ...

s=&ns;::value_string&lt;short&gt;::toString(n, l);

// ...

n=&ns;::value_string&lt;short&gt;::fromString(s.begin(), s.end(), l);

// ...

ws=&ns;::value_string&lt;short&gt;::toWideString(n, l);

// ...

n=&ns;::value_string&lt;short&gt;::fromWideString(ws.begin(), ws.end(), l);</programlisting>

    </informalexample>
  </blockquote>

  <para>
    The
    <ulink url="&link-x--value-string;"><classname>&ns;::value_string</classname></ulink>
    defines the following functions:
  </para>

  <variablelist>
    <varlistentry>
      <term>std::string <methodname>toString</methodname>(value, locale)</term>
      <listitem>
	<para>
	  <methodname>toString</methodname>()
	  takes the instance of the template class parameter and converts
	  it to a <classname>std::string</classname> using the locale given
	  by the second parameter.
	</para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>value <methodname>fromString</methodname>(string, locale)</term>
      <listitem>
	<para>
	  <methodname>fromString</methodname>()
	  is the opposite, taking a string parameter, and converting it
	  to the value specified by the template class parameter.
	</para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><methodname>toWideString</methodname>() and <methodname>fromWideString</methodname>()</term>
      <listitem>
	<para>
	  These functions are wide-character versions of
	  <methodname>toString</methodname>()
	  and
	  <methodname>fromString</methodname>()
	</para>
      </listitem>
    </varlistentry>
  </variablelist>

  <para>
    For all natural integer and floating types,
    <classname>&ns;::value_string</classname> uses standard library functions
    to effect the conversion.
    The template parameter may also be a <classname>std::string</classname>,
    which results in a <methodname>fromString</methodname>() and
    <methodname>toString</methodname>() that are effectively no-ops.
    For a <classname>std::wstring</classname>,
    <methodname>fromString</methodname>() and
    <methodname>toString</methodname>() uses the
    <link linkend="localeobj">locale object</link> to implement conversion
    between narrow and wide characters.

    Similarly, if the template parameter is a
    <classname>std::wstring</classname>,
    which results in a <methodname>fromWideString</methodname>() and
    <methodname>toWideString</methodname>() are effective no-ops, and
    for a <classname>std::string</classname> the conversion gets implemented
    via the locale object.
  </para>

  <section id="customstringability">

    <title>Using <classname>&ns;::value_string</classname> with custom classes</title>

    <para>
      The <classname>&ns;::value_string</classname> template class works with
      <link linkend="intervals"><classname>&ns;::hms</classname>
      and
      <classname>&ns;::ymd::interval</classname></link>,
      <link linkend="uri"><classname>&ns;::uriimpl</classname></link>, and
      <link linkend="uuid"><classname>&ns;::uuid</classname></link> classes.

      To implement <classname>&ns;::value_string</classname> for any class,
      define the <varname>stringable</varname> class member, and several
      member templates.

      This is done for the purpose of converting an object into
      some human readable form.
      <link linkend="serialization">Object serialization</link> template API
      would be more appropriate for saving and storing objects where
      readability is not a concern.
    </para>

    <blockquote>
      <informalexample>
	<programlisting>
#include &lt;&ns;/value_stringable.H&gt;

// ...

class Widget {

public:

    static const &ns;::stringable_t stringable=&ns;::class_toboth;

    template&lt;typename OutputIterator&gt;
    OutputIterator toString(OutputIterator iter,
                            const &ns;::const_locale &amp;localeRef)
		const
    {
        //

        return iter;
    }
      

    template&lt;typename InputIterator&gt;
    static Widget fromString(InputIterator beg_iter,
                              InputIterator end_iter,
                              const const_locale &amp;localeArg)
    {
        Widget w;

        //

        return w;
    }

    template&lt;typename OutputIterator&gt;
    OutputIterator toWideString(OutputIterator iter,
                                const &ns;::const_locale &amp;localeRef)
		const
    {
        //

        return iter;
    }
      

    template&lt;typename InputIterator&gt;
    static Widget fromWideString(InputIterator beg_iter,
                                 InputIterator end_iter,
                                 const const_locale &amp;localeArg)
    {
        Widget w;

        //

        return w;
    }
};

// ...

Widget wInstance;
&ns;::locale l;

std::string s=&ns;::value_string&lt;Winder&gt;::toString(wInstance, l);

</programlisting>
      </informalexample>
    </blockquote>

    <para>
      The stringable class defines <methodname>toString</methodname>() and
      <methodname>fromString</methodname>(); and/or
      <methodname>toWideString</methodname>() and
      <methodname>fromWideString</methodname>().

    </para>

    <para>
      The static const <varname>stringable</varname> member, in the example
      above, must be set to one of the following values:
    </para>

    <variablelist>
      <varlistentry>
	<term><literal>&ns;::class_tostring</literal></term>
	<listitem>
	  <para>
	    This class defines the
	    <methodname>toString</methodname>() and
	    <methodname>fromString</methodname>() template methods.
	  </para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term><literal>&ns;::class_tostring_utf8</literal></term>
	<listitem>
	  <para>
	    This class defines the
	    <methodname>toString</methodname>() and
	    <methodname>fromString</methodname>() template methods, that ignore
	    their locale argument, and always use the <quote>UTF-8</quote>
	    codeset.
	  </para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term><literal>&ns;::class_towstring</literal></term>
	<listitem>
	  <para>
	    This class defines the
	    <methodname>toWideString</methodname>() and
	    <methodname>fromWideString</methodname>() template methods.
	  </para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term><literal>&ns;::class_toboth</literal></term>
	<listitem>
	  <para>
	    This class defines all four template methods.
	  </para>
	</listitem>
      </varlistentry>
    </variablelist>

    <para>
      The <methodname>toString</methodname>() and
      <methodname>toWideString</methodname>() const template methods take an output
      iterator and a <link linkend="localeobj">locale object</link>
      (which they may ignore, if it's irrelevant for this class), write the
      string (in <methodname>toString</methodname>()'s case) or the
      wide string (in <methodname>toWideString</methodname>()'s case)
      representation of the object into the output iterator, and
      returns the new iterator value.

      <methodname>fromString</methodname>() and
      <methodname>fromWideString</methodname>()
      must be a static methods that take
      a pair of iterators. The pair
      specifies the beginning and the end of a character or a wide character
      sequence. The third argument is a
      locale object.
      <methodname>fromString</methodname>()
      and <methodname>fromWideString</methodname>() convert the character
      sequence to a new object instance, and return it.
    </para>

    <para>
      <classname>&ns;::value_string</classname>'s methods invoke the appropriate
      class methods, automatically converting between narrow and wide characters
      if the requested
      <classname>&ns;::value_string</classname> method is not directly
      supported by the class.
    </para>

    <para>
      <methodname>fromString</methodname>() and
      <methodname>fromWideString</methodname>()
      should throw an exception if they cannot parse the string.
      Furthermore, the beginning and ending iterator sequence should define
      the complete parsable sequence, and an exception should be thrown
      if the object gets converted without consuming the entire input
      sequence (however, the methods can allow this, if they want to).
    </para>

    <section id="tostring">
      <title>Convenience functions</title>

      <blockquote>
	<informalexample>
	  <programlisting>
#include &lt;&ns;/tostring.H&gt;

&ns;::locale l;

class Widget;

// ...

Widget w;

// ...

std::string s=&ns;::tostring(w, l);

std::string s=&ns;::towstring(w, l);</programlisting>
	</informalexample>
      </blockquote>

      <para>
	<methodname>&ns;::tostring</methodname>() and
	<methodname>&ns;::towstring</methodname>() are convenience functions
	that invoke
	<methodname>&ns;::value_string&lt;class&gt;::toString</methodname>() and
	<methodname>&ns;::value_string&lt;class&gt;::toWideString</methodname>().
	They are also overloaded for native character and wide character
	pointers, which become either effective no-ops, or
	a conversion call between narrow and wide characters, in the
	specified locale.
      </para>
    </section>
  </section>
</chapter>
<!--
Local Variables:
mode: sgml
sgml-parent-document: ("book.xml" "part" "chapter")
End:
-->
