<!--

Copyright 2014 Double Precision, Inc.
See COPYING for distribution information.

-->

<chapter id="callback">
  <title>Reference-counted lambdas (callbacks)</title>

  <para>
    The <ulink url="&link-typedef-x-callback;"><classname>&ns;::callback</classname></ulink>
    template creates a reference-counted wrapper for some arbitrary lambda.
    The template turns a lambda into a <link linkend="refobj">generic
      reference-counted object</link>. This is a generalized callback
    design pattern.
  </para>

  <blockquote>
    <informalexample>
      <programlisting>
&ns;::callback&lt;void, const char *, int&gt; cb=
    &ns;::callback&lt;void, const char *, int&gt;::create(
        []
        (const char *str, int n)
        {
            std::cout &lt;&lt; str &lt;&lt; ": " &lt;&lt; n &lt;&lt; std::endl;
        });

// ...

cb-&gt;invoke("Hello world", 0);</programlisting>
    </informalexample>
  </blockquote>

  <para>
    The first parameter to the <classname>&ns;::callback</classname> template
    is the lambda's return type. The remaining parameters to the template
    are the types of the arguments to the lambda (if any).
    This constructs a reference-counted object whose invoke() method
    invokes the lambda.
  </para>

  <section id="invoke_callbacks">
    <title>Invoking a weak list of callbacks</title>

    <para>
      A common design pattern is to store a list of registered callbacks in
      a <link linkend="weakcontainers">weak list</link>, so that callbacks
      get automatically deregistered, when they go out of scope and get
      destroyed. The following methods implement a typical mechanism to
      invoke the callbacks:
    </para>

    <blockquote>
      <informalexample>
	<programlisting>
&ns;::weaklist&lt;callbackObj&lt;void, int, const char *&gt;&gt; callbacks;

invoke_callbacks(callbacks, "Hello world", 0);

invoke_callbacks_log_exceptions(callbacks, "Hello world", 0);</programlisting>
      </informalexample>
    </blockquote>

    <para>
      <function>invoke_callbacks</function>()'s first parameter is a
      weak list of callbacks.
      <function>invoke_callbacks</function>() invokes each callback in the
      weak list,
      with its remaining arguments forwarded to each callback.
      <function>invoke_callbacks</function>() does not catch
      any <link linkend="exceptions"><classname>&ns;::exception</classname></link>s
      thrown from an invoked callback. A thrown exceptions stops
      any remaining callbacks in the list from getting invoked.
      <function>invoke_callbacks_log_exceptions</function>()
      catches any <classname>&ns;::exception</classname> that gets thrown
      from an invoked callback. The caught exception is logged before
      the next callback in the weak list gets invoked.
    </para>

    <para>
      Callback lambdas that return non-<classname>void</classname>
      values require two extra parameters:
    </para>

    <blockquote>
      <informalexample>
	<programlisting>
&ns;::weaklist&lt;callbackObj&lt;int, int, const char *&gt;&gt; callbacks;

int retval=invoke_callbacks(callbacks,
    []
    (int value)
    {
        return value &lt; 0;
    },
    []
    {
        return 0;
    },
    "Hello world", 0);</programlisting>
      </informalexample>
    </blockquote>

    <para>
      Using <function>invoke_callbacks</function>() and
      <function>invoke_callbacks_log_exceptions</function>() with a weak list
      of callbacks that return a non-<classname>void</classname> value requires
      the following parameters:
    </para>

    <itemizedlist>
      <listitem>
	<para>
	  The weak list of callbacks itself.
	</para>
      </listitem>

      <listitem>
	<para>
	  A lambda that checks the return value from each callback.
	  If the lambda returns <literal>true</literal>, callback invocation
	  stops.
	  Any remaining callbacks do not get invoked, and
	  <function>invoke_callbacks</function>() or
	  <function>invoke_callbacks_log_exceptions</function>() returns
	  immediately, with the last callback's return value.
	</para>
      </listitem>

      <listitem>
	<para>
	  A lambda that returns the value that
	  <function>invoke_callbacks</function>() or
	  <function>invoke_callbacks_log_exceptions</function>() itself returns
	  if the weak list is empty, or if the first lambda returned
	  <literal>false</literal> for every invoked callback's value.
	</para>
      </listitem>

      <listitem>
	<para>
	  The remaining parameters get forwarded to each invoked callback.
	</para>
      </listitem>
    </itemizedlist>
  </section>

  <section id="weakcapture">
    <title>Lambda weak pointer captures</title>

    <blockquote>
      <informalexample>
	<programlisting>
typedef &ns;::ref&lt;widgetObj&gt; widget;

widget w=widget::create();

&ns;::callback&lt;void, const char *, int&gt; cb=
    &ns;::callback&lt;void, const char *, int&gt;::create(
        [w]
        (const char *str, int n)
        {
               w-&gt;method(str, n);
        });</programlisting>
      </informalexample>
    </blockquote>

    <para>
      In this example, the <link linkend="callback">lambda</link>
      captures a <link linkend="refobj">reference to an object</link>,
      and the lambda will keep its reference to the object until the callback
      itself goes out of scope, and gets destroyed.
    </para>

    <para>
      Sometimes it's desirable for lambdas to capture a
      <link linkend="weakptr">weak pointer reference</link> to an object,
      so that the
      existence of the callback does not affect the scope of the object's
      existence, if possible. When the lambda gets invoked, an attempt gets
      made to recover a regular strong reference to the object, and then use
      it, and take no action if the object already went out of scope and
      got destroyed.
    </para>

    <para>
      This is often the case when the callback is closely related to the
      object. Very often, the object itself will want to install a callback
      lambda that uses the object's own method when it gets invoked, with
      the object owning the only strong reference to an object. For example:
    </para>

    <blockquote>
      <informalexample>
	<programlisting>
class bObj;

typedef &ns;::ref&lt;bObj&gt; b;

class aObj;

typedef &ns;::ref&lt;aObj&gt; a;
typedef &ns;::ptr&lt;aObj&gt; aptr;

class aObj : virtual public &ns;::obj {

    &ns;::callbackptr&lt;void&gt; b_callback;

public:

    void initialize(const b &amp;b_object)
    {
        auto cb=&ns;::callback&lt;void&gt;::create(
	    [weak_a=&ns;::weakptr&lt;aptr&gt;(aptr(this))]
	    {
	        auto a_strong=weak_a.getptr();

		if (!a_strong.null())
		    a_strong-&gt;do_something();
	    });

        b_object-&gt;install(cb);
        b_callback=cb;
    }
};</programlisting>
      </informalexample>
    </blockquote>

    <para>
      This is an example of an instance of one class,
      <classname>aObj</classname>,
      installing a callback in an instance of a second class,
      <classname>bObj</classname>. When the second class invokes the callback,
      the callback then invokes the <methodname>do_something</methodname>()
      method of the first class.
    </para>

    <para>
      With this approach, the second class itself maintains only weak
      references to the installed callbacks (typically using a
      <link linkend="weakcontainers">weak list</link> of callbacks.

      When all other references to the first class go out of scope and
      get destroyed, the only strong reference to the callback also goes out
      of scope, and the callback itself gets destroyed, removing it from
      the second class's weak list container.
    </para>

    <para>
      In this example, the lambda must capture a weak pointer to its own
      class instance, otherwise a circular strong reference gets created:
      the class instance owns a strong reference to the callback, and the
      callback owns a strong reference on the same class instance. In this
      case, other measures must get implemented to explicitly deinstall and
      destroy the callback, in order for all references here to go out of
      scope, and the underlying objects gets destroyed.
    </para>

    <para>
      The callback recovers a strong to its class instance, and invokes its
      method. Note that it's possible that while the callback is holding its
      own temporary strong reference to the class instance, all other strong
      references to the class instance go out of scope. When the
      <methodname>do_something</methodname>() method returns, the temporary
      reference to the instance will go out of scope, and with that being
      the last reference to the instance, it finally gets destroyed.
    </para>

    <blockquote>
      <informalexample>
	<programlisting>
#include &lt;&ns;/weakcapture.H&gt;

// ...
        auto cb=&ns;::callback&lt;void&gt;::create(
	    [refs=&ns;::make_weak_capture(a(this))]
	  {
              refs.get([]
	               (const a &amp;me)
	               {
	                    me-&gt;do_something();
	               });
          });
        </programlisting>
      </informalexample>
    </blockquote>

    <para>
      <ulink url="&link-function-x-make-weak-capture;"><function>&ns;::make_weak_capture</function></ulink>()
      takes a variadic list of <classname>&ns;::ref</classname>s to any
      object, and returns an opaque container of weak references to all the
      referenced objects.
      This ends up being captured by this lambda.
    </para>

    <para>
      The opaque container's <methodname>get</methodname>()
      method recovers the strong references from the weakly-referenced
      objects, and invokes the lambda parameter, passing them as its arguments.
      If <methodname>get</methodname>() can
      <link linkend="weakcontainers">getptr</link>() back all
      weak pointer, <function>&ns;::get_weak_capture</function>()
      invokes the lambda it receives as its second parameter, forwarding
      to the lambda all the references to the recovered objects.
    </para>

    <para>
      <methodname>get</methodname>() returns
      <literal>true</literal>, if
      <methodname>get</methodname>() was able to
      recover strong references from all weak references, and invoke
      the lambda,
      <methodname>get</methodname>() returns
      <literal>false</literal>, and does not invoke the lambda,
      if one or more weakly-referenced object already went out of scope
      and got destroyed.
    </para>

    <para>
      With this approach, the callback action only takes place if all
      weakly-referenced objects still exists. In most situations, a
      callback getting invoked with one of them already destroyed usually
      happens in a transient race condition, where related object are
      being destroyed, but some of them, including the ones involved with
      the callback, still existing.
    </para>
  </section>
</chapter>
<!--
Local Variables:
mode: sgml
sgml-parent-document: ("book.xml" "book" "chapter")
End:
-->
