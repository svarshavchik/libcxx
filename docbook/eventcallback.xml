<!--

Copyright 2012 Double Precision, Inc.
See COPYING for distribution information.

-->

<chapter id="eventcallback">
  <title>Event callbacks</title>

  <para>
    The event callback framework is a lightweight alternative to an
    <link linkend="eventfactory">event factory</link> which does not use
    a registration handle. Rather, a callback object gets registered, and it
    remains registered and receives events until the callback object goes
    out of scope and gets destroyed, at which point it, naturally, stops
    receiving events.
  </para>

  <blockquote>
    <informalexample>
      <programlisting>
class mycbObj : public &ns;::eventcallback&lt;int&gt;::baseObj {

public:
	int sum;

	mycbObj() : sum(0)
	{
	}

	~mycbObj() noexcept
	{
	}

	void event(const int &amp;n)
	{
		sum += n;
	}
};

typedef &ns;::ptr&lt;mycbObj&gt; mycb;

&ns;::eventcallback&lt;int&gt; callback_list;

mycb cb(mycb::create());

// ...

callback_list.install(cb);

// ...

callback_list.event(3);</programlisting>
    </informalexample>
  </blockquote>

  <para>
    The parameter to the
    <ulink url="&link-x--eventcallback;"><classname>&ns;::eventcallback</classname></ulink> is the
    type of the argument that's received by registered callbacks.
    The argument gets passed to the <classname>eventcallback</classname>'s
    <methodname>event</methodname>() method.
  </para>

  <para>
    The
    <link linkend="refobj">reference-counted</link>.
    callback objects must be subclassed from
    <classname>eventcallback&lt;argtype&gt;::baseObj</classname>, and all
    registered callback objects' <methodname>event</methodname>() methods get
    invoked and receive the event argument.
  </para>

  <para>
    The <classname>&ns;::eventcallback&lt;void&gt;</classname> specialization
    defines a callback mechanism without any arguments. It's
    <methodname>event</methodname>() method, and the virtual
    <methodname>event</methodname>() in <classname>baseObj</classname> does not
    take arguments.
  </para>

  <section id="customeventcallbacks">
    <title>Using the same callback objects for multiple callbacks</title>

    <para>
      It's possible to invoke a different method than
      <methodname>event</methodname>() in a callback object, and have different
      methods in the same callback object used by different callback
      notifications.
    </para>
    <blockquote>
      <informalexample>
	<programlisting>
class customcbObj : virtual public &ns;::obj {

public:

	int sum;

	customcbObj() : sum(0)
	{
	}

	~customcbObj() noexcept
	{
	}

	void event_int(int n)
	{
		sum += n;
	}

	void event_void()
	{
		sum = -sum;
	}
};

typedef &ns;::ptr&lt;customcbObj&gt; customcb;

class invoke_int {

public:

	static void event(const &ns;::ptr&lt;customcbObj&gt; &amp;cb,
			  int arg)
	{
		cb-&gt;event_int(arg);
	}
};

class invoke_void {

public:

	static void event(const &ns;::ptr&lt;customcbObj&gt; &amp;cb)
	{
		cb-&gt;event_void();
	}
};

// ...

customcb cb(customcb::create());

&ns;::eventcallback&lt;int, customcbObj, invoke_int&gt; cb_int;

&ns;::eventcallback&lt;void, customcbObj, invoke_void&gt; cb_void;

cb_int.install(cb);
cb_void.install(cb);

cb_int.event(4);
cb_void.event();</programlisting>
      </informalexample>
    </blockquote>

    <para>
      The second template to <classname>eventcallback</classname> specifies the
      callback class name (which gets <literal>typedef</literal>ed to the
      <classname>baseObj</classname> member class). The third parameter is a
      class that implements a static <methodname>event</methodname>() method
      that receives a reference to a registered callback object, and
      the callback argument (if it's not a <classname>void</classname>
      callback).
    </para>

    <para>
      The above example implements two callbacks that may be used with the
      same handler, one that takes an <classname>int</classname> argument and
      one that takes no arguments.
    </para>
  </section>
</chapter>


