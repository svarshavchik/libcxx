/*
** Copyright 2012-2021 Double Precision, Inc.
** See COPYING for distribution information.
*/
#ifndef x_mime_rfc2047_H
#define x_mime_rfc2047_H

#include <x/namespace.h>
#include <x/locale.H>
#include <x/iconviofilter.H>
#include <string>
#include <utility>
#include <courier-unicode.h>

namespace LIBCXX_NAMESPACE::mime {
#if 0
}
#endif

//! Implementation class for formatting a string using RFC 2047 encoding.

class rfc2047_encode_base {

public:
	//! String generated by encode().

	std::string formatted_string;

	//! Constructor
	rfc2047_encode_base();

	//! Destructor
	~rfc2047_encode_base();

	//! Encode it.
	void encode(//! Language, empty for unspecified language.
		    const std::string &language,

		    //! String
		    const std::u32string &text);

	//! Subclass specifies whether any additional characters should trigger encoding.

	virtual bool do_encode(char32_t c)=0;

private:

	//! Internal word-scanning function

	//! \internal

	std::u32string::const_iterator
	next_word(std::u32string::const_iterator b,
		  std::u32string::const_iterator e, bool &encode_it)
		LIBCXX_HIDDEN;

	//! Internal method.

	//! \internal
	std::string do_encode(const std::string &utf8,
			      size_t maximum_length,
			      const std::string &language)
		LIBCXX_HIDDEN;

	//! Internal method.

	//! \internal
	std::string do_qp(const std::string &utf8,
			  size_t maximum_length,
			  const std::string &language)
		LIBCXX_HIDDEN;

	//! Internal method.

	//! \internal
	std::string do_base64(const std::string &utf8,
			      size_t maximum_length,
			      const std::string &language)
		LIBCXX_HIDDEN;

	//! Internal method.

	//! \internal
	static std::string to_utf8(std::u32string::const_iterator b,
				   std::u32string::const_iterator e)
		LIBCXX_HIDDEN;

	class qp_traits;
};

//! Use a lambda/functor for rfc2047_encode_base::do_encode().

//! \internal
template<typename encode_functor>
class rfc2047_encode_impl : public rfc2047_encode_base {

	//! The lambda/functor
	encode_functor functor;

public:

	//! Constructor
	template<typename Arg>
	rfc2047_encode_impl(Arg && functorArg)
		: functor(std::forward<Arg>(functorArg))
	{
	}

	//! Invoke the lambda/functor.

	bool do_encode(char32_t c)
	{
		return functor(c);
	}
};

//! Encode a string using RFC 2047.

std::string to_rfc2047(const std::u32string &str);

//! Encode a string using RFC 2047, specifying the language.

//! \overload
//! Uses the RFC 2231 extension to RFC 2047 to indicate the language.
std::string to_rfc2047(const std::string &language,
		       const std::u32string &str);

//! Encode a string using RFC 2047.

//! \overload
//! The second parameter is a functor/lambda that takes a \c char32_t argument,
//! a unicode character. It should return \c true if the character should be
//! encoded, even though it isn't by default. Used in syntactical contexts
//! which encode characters that are not otherwise required to be encoded.

template<typename Functor>
std::string to_rfc2047(//! String, unspecified language
		       const std::u32string &str,

		       //! Functor
		       Functor && functor)
{
	return to_rfc2047(std::string(""), str, std::forward<Functor>(functor));
}

//! Encode a string using RFC 2047.

//! \overload
template<typename Functor>
std::string to_rfc2047(//! Language
		       const std::string &language,

		       //! String
		       const std::u32string &str,

		       //! Functor
		       Functor && functor)
{
	rfc2047_encode_impl<typename std::decay<Functor>::type> encode(functor);

	encode.encode(language, str);
	return encode.formatted_string;
}

//! Encode a UTF-8 string using RFC 2047, in a specified language

//! This is a convenience function that invokes to_rfc2047() after converting
//! its first parameter using iconviofilter.

template<typename ...Args>
std::string to_rfc2047_lang_utf8(//! Language
				 const std::string &language,

				 //! UTF-8 string to encode
				 const std::string &str,

				 //! An optional functor/lambda
				 Args && ...args)
{
	std::u32string uc;

	unicode::iconvert::convert(str, unicode::utf_8, uc);

	return to_rfc2047(language,
			  uc,
			  std::forward<Args>(args)...);
}

//! Encode a UTF-8 string using RFC 2047, in an unspecified language

//! This is a convenience function that invokes to_rfc2047() after converting
//! its first parameter using iconviofilter.

template<typename ...Args>
std::string to_rfc2047_utf8(//! UTF-8 string to encode
			    const std::string &str,

			    //! An optional functor/lambda
			    Args && ...args)
{
	return to_rfc2047_lang_utf8("", str,
			       std::forward<Args>(args)...);
}

//! Decode an RFC2047-encoded string.

//! Use \ref iconviofilter "LIBCXX_NAMESPACE::iconviofilter::from_u32string()"
//! to get a regular string.

std::u32string from_rfc2047(//! RFC 2047-encoded string
			    const std::string &string,

			    //! Expected charset of unencoded octets
			    const std::string &native_charset);

//! Decode an RFC2047-encoded string, returning the language, if specified

//! Returns a \c std::pair of the specified language, or an empty string,
//! and the decoded string.
//!
//! If the RFC2047-encoded string indicated multiple languages, the first
//! one gets returned.

std::pair<std::string, std::u32string>
from_rfc2047_lang(//! RFC2047-encoded string
		  const std::string &string,

		  //! Expected charset of unencoded octets
		  const std::string &native_charset);

//! Complete decoding of RFC-2047 encoded string.

void from_rfc2047(//! RFC2047-encoded string
		  const std::string &string,

		  //! Expected charset of unencoded octets
		  const std::string &native_charset,

		  //! Decoded string, as a list of language/strings.
		  std::vector<std::pair<std::string, std::u32string>
		  > &res);

//! Converted from RFC 2047 to a UTF-8 string
std::string from_rfc2047_as_utf8(//! RFC2047-encoded string
				 const std::string &string,

				 //! Expected charset of unencoded octets
				 const std::string &native_charset);

#if 0
{
#endif
}
#endif
